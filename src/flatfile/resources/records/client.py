# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ..commons.errors.bad_request_error import BadRequestError
from ..commons.errors.not_found_error import NotFoundError
from ..commons.types.errors import Errors
from ..commons.types.event_id import EventId
from ..commons.types.filter import Filter
from ..commons.types.filter_field import FilterField
from ..commons.types.record_id import RecordId
from ..commons.types.search_field import SearchField
from ..commons.types.search_value import SearchValue
from ..commons.types.sheet_id import SheetId
from ..commons.types.sort_direction import SortDirection
from ..commons.types.sort_field import SortField
from ..commons.types.success import Success
from ..commons.types.version_id import VersionId
from ..versions.types.version_response import VersionResponse
from .types.cell_value_union import CellValueUnion
from .types.get_records_response import GetRecordsResponse
from .types.record_data import RecordData
from .types.records import Records
from .types.records_response import RecordsResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RecordsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[str] = None,
        since_version_id: typing.Optional[VersionId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        include_counts: typing.Optional[bool] = None,
        include_length: typing.Optional[bool] = None,
        include_links: typing.Optional[bool] = None,
        include_messages: typing.Optional[bool] = None,
        for_: typing.Optional[EventId] = None,
        q: typing.Optional[str] = None,
    ) -> GetRecordsResponse:
        """
        Returns records from a sheet in a workbook

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - version_id: typing.Optional[str].

            - since_version_id: typing.Optional[VersionId].

            - sort_field: typing.Optional[SortField].

            - sort_direction: typing.Optional[SortDirection].

            - filter: typing.Optional[Filter].

            - filter_field: typing.Optional[FilterField]. Name of field by which to filter records

            - search_value: typing.Optional[SearchValue].

            - search_field: typing.Optional[SearchField].

            - ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]]. The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records. Maximum of 100 allowed.

            - page_size: typing.Optional[int]. Number of records to return in a page (default 1000 if pageNumber included)

            - page_number: typing.Optional[int]. Based on pageSize, which page of records to return

            - include_counts: typing.Optional[bool]. **DEPRECATED** Use GET /sheets/:sheetId/counts

            - include_length: typing.Optional[bool]. The length of the record result set, returned as counts.total

            - include_links: typing.Optional[bool]. If true, linked records will be included in the results. Defaults to false.

            - include_messages: typing.Optional[bool]. Include error messages, defaults to false.

            - for_: typing.Optional[EventId]. if "for" is provided, the query parameters will be pulled from the event payload

            - q: typing.Optional[str]. An FFQL query used to filter the result set
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/records"),
            params=remove_none_from_dict(
                {
                    "versionId": version_id,
                    "sinceVersionId": since_version_id,
                    "sortField": sort_field,
                    "sortDirection": sort_direction,
                    "filter": filter,
                    "filterField": filter_field,
                    "searchValue": search_value,
                    "searchField": search_field,
                    "ids": ids,
                    "pageSize": page_size,
                    "pageNumber": page_number,
                    "includeCounts": include_counts,
                    "includeLength": include_length,
                    "includeLinks": include_links,
                    "includeMessages": include_messages,
                    "for": for_,
                    "q": q,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetRecordsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(self, sheet_id: SheetId, *, request: Records) -> VersionResponse:
        """
        Updates existing records in a workbook sheet

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - request: Records.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/records"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VersionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def insert(self, sheet_id: SheetId, *, request: typing.List[RecordData]) -> RecordsResponse:
        """
        Adds records to a workbook sheet

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - request: typing.List[RecordData].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/records"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(
        self, sheet_id: SheetId, *, ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]] = None
    ) -> Success:
        """
        Deletes records from a workbook sheet

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]]. The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records

        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/records"),
            params=remove_none_from_dict({"ids": ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def find_and_replace_deprecated(
        self,
        sheet_id: SheetId,
        *,
        field_key: str,
        search_value: str,
        filter: typing.Optional[Filter] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        replace: typing.Any,
    ) -> RecordsResponse:
        """
        Searches for the given searchValue in a field and replaces all instances of that value with replaceValue

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - field_key: str. A unique key used to identify a field in a sheet

            - search_value: str. A value to find for a given field in a sheet. Wrap the value in "" for exact match

            - filter: typing.Optional[Filter].

            - page_size: typing.Optional[int]. Number of records to return in a page (default 1000 if pageNumber included)

            - page_number: typing.Optional[int]. Based on pageSize, which page of records to return

            - replace: typing.Any. The value to replace found values with
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/replace"),
            params=remove_none_from_dict(
                {
                    "fieldKey": field_key,
                    "searchValue": search_value,
                    "filter": filter,
                    "pageSize": page_size,
                    "pageNumber": page_number,
                }
            ),
            json=jsonable_encoder({"replace": replace}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordsResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def find_and_replace(
        self,
        sheet_id: SheetId,
        *,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]] = None,
        find: typing.Optional[CellValueUnion] = OMIT,
        replace: typing.Optional[CellValueUnion] = OMIT,
        field_key: str,
    ) -> VersionResponse:
        """
        Searches for all values that match the 'find' value (globally or for a specific field via 'fieldKey') and replaces them with the 'replace' value. Wrap 'find' value in double quotes for exact match (""). Returns a versionId for the updated records

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - filter: typing.Optional[Filter].

            - filter_field: typing.Optional[FilterField]. Name of field by which to filter records

            - search_value: typing.Optional[SearchValue].

            - search_field: typing.Optional[SearchField].

            - ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]]. The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records

            - find: typing.Optional[CellValueUnion]. A value to find for a given field in a sheet. Wrap the value in "" for exact match

            - replace: typing.Optional[CellValueUnion]. The value to replace found values with

            - field_key: str. The value to replace found values with
        """
        _request: typing.Dict[str, typing.Any] = {"fieldKey": field_key}
        if find is not OMIT:
            _request["find"] = find
        if replace is not OMIT:
            _request["replace"] = replace
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/find-replace"),
            params=remove_none_from_dict(
                {
                    "filter": filter,
                    "filterField": filter_field,
                    "searchValue": search_value,
                    "searchField": search_field,
                    "ids": ids,
                }
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VersionResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncRecordsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[str] = None,
        since_version_id: typing.Optional[VersionId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        include_counts: typing.Optional[bool] = None,
        include_length: typing.Optional[bool] = None,
        include_links: typing.Optional[bool] = None,
        include_messages: typing.Optional[bool] = None,
        for_: typing.Optional[EventId] = None,
        q: typing.Optional[str] = None,
    ) -> GetRecordsResponse:
        """
        Returns records from a sheet in a workbook

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - version_id: typing.Optional[str].

            - since_version_id: typing.Optional[VersionId].

            - sort_field: typing.Optional[SortField].

            - sort_direction: typing.Optional[SortDirection].

            - filter: typing.Optional[Filter].

            - filter_field: typing.Optional[FilterField]. Name of field by which to filter records

            - search_value: typing.Optional[SearchValue].

            - search_field: typing.Optional[SearchField].

            - ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]]. The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records. Maximum of 100 allowed.

            - page_size: typing.Optional[int]. Number of records to return in a page (default 1000 if pageNumber included)

            - page_number: typing.Optional[int]. Based on pageSize, which page of records to return

            - include_counts: typing.Optional[bool]. **DEPRECATED** Use GET /sheets/:sheetId/counts

            - include_length: typing.Optional[bool]. The length of the record result set, returned as counts.total

            - include_links: typing.Optional[bool]. If true, linked records will be included in the results. Defaults to false.

            - include_messages: typing.Optional[bool]. Include error messages, defaults to false.

            - for_: typing.Optional[EventId]. if "for" is provided, the query parameters will be pulled from the event payload

            - q: typing.Optional[str]. An FFQL query used to filter the result set
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/records"),
            params=remove_none_from_dict(
                {
                    "versionId": version_id,
                    "sinceVersionId": since_version_id,
                    "sortField": sort_field,
                    "sortDirection": sort_direction,
                    "filter": filter,
                    "filterField": filter_field,
                    "searchValue": search_value,
                    "searchField": search_field,
                    "ids": ids,
                    "pageSize": page_size,
                    "pageNumber": page_number,
                    "includeCounts": include_counts,
                    "includeLength": include_length,
                    "includeLinks": include_links,
                    "includeMessages": include_messages,
                    "for": for_,
                    "q": q,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetRecordsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(self, sheet_id: SheetId, *, request: Records) -> VersionResponse:
        """
        Updates existing records in a workbook sheet

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - request: Records.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/records"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VersionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def insert(self, sheet_id: SheetId, *, request: typing.List[RecordData]) -> RecordsResponse:
        """
        Adds records to a workbook sheet

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - request: typing.List[RecordData].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/records"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self, sheet_id: SheetId, *, ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]] = None
    ) -> Success:
        """
        Deletes records from a workbook sheet

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]]. The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records

        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/records"),
            params=remove_none_from_dict({"ids": ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def find_and_replace_deprecated(
        self,
        sheet_id: SheetId,
        *,
        field_key: str,
        search_value: str,
        filter: typing.Optional[Filter] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        replace: typing.Any,
    ) -> RecordsResponse:
        """
        Searches for the given searchValue in a field and replaces all instances of that value with replaceValue

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - field_key: str. A unique key used to identify a field in a sheet

            - search_value: str. A value to find for a given field in a sheet. Wrap the value in "" for exact match

            - filter: typing.Optional[Filter].

            - page_size: typing.Optional[int]. Number of records to return in a page (default 1000 if pageNumber included)

            - page_number: typing.Optional[int]. Based on pageSize, which page of records to return

            - replace: typing.Any. The value to replace found values with
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/replace"),
            params=remove_none_from_dict(
                {
                    "fieldKey": field_key,
                    "searchValue": search_value,
                    "filter": filter,
                    "pageSize": page_size,
                    "pageNumber": page_number,
                }
            ),
            json=jsonable_encoder({"replace": replace}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordsResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def find_and_replace(
        self,
        sheet_id: SheetId,
        *,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]] = None,
        find: typing.Optional[CellValueUnion] = OMIT,
        replace: typing.Optional[CellValueUnion] = OMIT,
        field_key: str,
    ) -> VersionResponse:
        """
        Searches for all values that match the 'find' value (globally or for a specific field via 'fieldKey') and replaces them with the 'replace' value. Wrap 'find' value in double quotes for exact match (""). Returns a versionId for the updated records

        Parameters:
            - sheet_id: SheetId. ID of sheet

            - filter: typing.Optional[Filter].

            - filter_field: typing.Optional[FilterField]. Name of field by which to filter records

            - search_value: typing.Optional[SearchValue].

            - search_field: typing.Optional[SearchField].

            - ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]]. The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records

            - find: typing.Optional[CellValueUnion]. A value to find for a given field in a sheet. Wrap the value in "" for exact match

            - replace: typing.Optional[CellValueUnion]. The value to replace found values with

            - field_key: str. The value to replace found values with
        """
        _request: typing.Dict[str, typing.Any] = {"fieldKey": field_key}
        if find is not OMIT:
            _request["find"] = find
        if replace is not OMIT:
            _request["replace"] = replace
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"sheets/{sheet_id}/find-replace"),
            params=remove_none_from_dict(
                {
                    "filter": filter,
                    "filterField": filter_field,
                    "searchValue": search_value,
                    "searchField": search_field,
                    "ids": ids,
                }
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VersionResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
