# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ..commons.errors.bad_request_error import BadRequestError
from ..commons.errors.not_found_error import NotFoundError
from ..commons.types.errors import Errors
from ..commons.types.filter import Filter
from ..commons.types.filter_field import FilterField
from ..commons.types.record_id import RecordId
from ..commons.types.search_field import SearchField
from ..commons.types.search_value import SearchValue
from ..commons.types.sheet_id import SheetId
from ..commons.types.sort_direction import SortDirection
from ..commons.types.sort_field import SortField
from ..commons.types.space_id import SpaceId
from ..commons.types.success import Success
from ..commons.types.version_id import VersionId
from ..commons.types.workbook_id import WorkbookId
from ..records.types.record_data import RecordData
from ..records.types.records import Records
from ..records.types.records_response import RecordsResponse
from ..sheets.types.list_sheets_response import ListSheetsResponse
from ..versions.types.version_response import VersionResponse
from .types.create_workbook_config import CreateWorkbookConfig
from .types.list_workbooks_response import ListWorkbooksResponse
from .types.workbook_response import WorkbookResponse
from .types.workbook_update import WorkbookUpdate

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class WorkbooksClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self, *, space_id: typing.Optional[SpaceId] = None, include_counts: typing.Optional[bool] = None
    ) -> ListWorkbooksResponse:
        """
        Returns all workbooks matching a filter for an account or space

        Parameters:
            - space_id: typing.Optional[SpaceId].

            - include_counts: typing.Optional[bool]. Include counts for the workbook
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "workbooks"),
            params=remove_none_from_dict({"spaceId": space_id, "includeCounts": include_counts}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListWorkbooksResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(self, *, request: CreateWorkbookConfig) -> WorkbookResponse:
        """
        Creates a workbook and adds it to a space

        Parameters:
            - request: CreateWorkbookConfig.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "workbooks"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WorkbookResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, workbook_id: WorkbookId) -> WorkbookResponse:
        """
        Returns a single workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to return
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WorkbookResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, workbook_id: WorkbookId) -> Success:
        """
        Deletes a workbook and all of its record data permanently

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to delete
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(self, workbook_id: WorkbookId, *, request: WorkbookUpdate) -> WorkbookResponse:
        """
        Updates a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to update

            - request: WorkbookUpdate.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WorkbookResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def clone(self, workbook_id: WorkbookId) -> WorkbookResponse:
        """
        Clones a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to clone
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/clone"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WorkbookResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_sheets_deprecated(self, workbook_id: WorkbookId) -> ListSheetsResponse:
        """
        Returns sheets from a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListSheetsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def rebuild_workbook(self, workbook_id: WorkbookId) -> Success:
        """
        Rebuild a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to rebuild
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/rebuild"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_records_deprecated(
        self,
        workbook_id: WorkbookId,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[VersionId] = None,
        until_version_id: typing.Optional[VersionId] = None,
        since_version_id: typing.Optional[VersionId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        include_counts: typing.Optional[bool] = None,
        include_links: typing.Optional[bool] = None,
        include_messages: typing.Optional[bool] = None,
    ) -> RecordsResponse:
        """
        Returns records from a sheet in a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet

            - version_id: typing.Optional[VersionId].

            - until_version_id: typing.Optional[VersionId].

            - since_version_id: typing.Optional[VersionId].

            - sort_field: typing.Optional[SortField].

            - sort_direction: typing.Optional[SortDirection].

            - filter: typing.Optional[Filter].

            - filter_field: typing.Optional[FilterField].

            - search_value: typing.Optional[SearchValue].

            - search_field: typing.Optional[SearchField].

            - page_size: typing.Optional[int]. Number of records to return in a page (default 1000 if pageNumber included)

            - page_number: typing.Optional[int]. Based on pageSize, which page of records to return

            - include_counts: typing.Optional[bool]. Include counts for the total records, valid records and records with errors

            - include_links: typing.Optional[bool]. If true, linked records will be included in the results. Defaults to false

            - include_messages: typing.Optional[bool]. Include error messages, defaults to false
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/records"
            ),
            params=remove_none_from_dict(
                {
                    "versionId": version_id,
                    "untilVersionId": until_version_id,
                    "sinceVersionId": since_version_id,
                    "sortField": sort_field,
                    "sortDirection": sort_direction,
                    "filter": filter,
                    "filterField": filter_field,
                    "searchValue": search_value,
                    "searchField": search_field,
                    "pageSize": page_size,
                    "pageNumber": page_number,
                    "includeCounts": include_counts,
                    "includeLinks": include_links,
                    "includeMessages": include_messages,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_records_deprecated(
        self, workbook_id: WorkbookId, sheet_id: SheetId, *, request: Records
    ) -> VersionResponse:
        """
        Updates existing records in a workbook sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet

            - request: Records.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/records"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VersionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_records_deprecated(
        self, workbook_id: WorkbookId, sheet_id: SheetId, *, request: typing.List[RecordData]
    ) -> RecordsResponse:
        """
        Adds records to a workbook sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet

            - request: typing.List[RecordData].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/records"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_records_deprecated(
        self,
        workbook_id: WorkbookId,
        sheet_id: SheetId,
        *,
        ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]] = None,
    ) -> Success:
        """
        Deletes records from a workbook sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet

            - ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]]. The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/records"
            ),
            params=remove_none_from_dict({"ids": ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def validate_sheet_deprecated(self, workbook_id: WorkbookId, sheet_id: SheetId) -> Success:
        """
        Trigger data hooks and validation to run on a sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/validate"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_version_deprecated(self, workbook_id: WorkbookId, sheet_id: SheetId) -> VersionResponse:
        """
        Creates a new version of a workbook sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/versions"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VersionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncWorkbooksClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self, *, space_id: typing.Optional[SpaceId] = None, include_counts: typing.Optional[bool] = None
    ) -> ListWorkbooksResponse:
        """
        Returns all workbooks matching a filter for an account or space

        Parameters:
            - space_id: typing.Optional[SpaceId].

            - include_counts: typing.Optional[bool]. Include counts for the workbook
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "workbooks"),
            params=remove_none_from_dict({"spaceId": space_id, "includeCounts": include_counts}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListWorkbooksResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(self, *, request: CreateWorkbookConfig) -> WorkbookResponse:
        """
        Creates a workbook and adds it to a space

        Parameters:
            - request: CreateWorkbookConfig.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "workbooks"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WorkbookResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, workbook_id: WorkbookId) -> WorkbookResponse:
        """
        Returns a single workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to return
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WorkbookResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, workbook_id: WorkbookId) -> Success:
        """
        Deletes a workbook and all of its record data permanently

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to delete
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(self, workbook_id: WorkbookId, *, request: WorkbookUpdate) -> WorkbookResponse:
        """
        Updates a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to update

            - request: WorkbookUpdate.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WorkbookResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def clone(self, workbook_id: WorkbookId) -> WorkbookResponse:
        """
        Clones a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to clone
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/clone"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WorkbookResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_sheets_deprecated(self, workbook_id: WorkbookId) -> ListSheetsResponse:
        """
        Returns sheets from a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListSheetsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def rebuild_workbook(self, workbook_id: WorkbookId) -> Success:
        """
        Rebuild a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook to rebuild
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/rebuild"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_records_deprecated(
        self,
        workbook_id: WorkbookId,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[VersionId] = None,
        until_version_id: typing.Optional[VersionId] = None,
        since_version_id: typing.Optional[VersionId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        include_counts: typing.Optional[bool] = None,
        include_links: typing.Optional[bool] = None,
        include_messages: typing.Optional[bool] = None,
    ) -> RecordsResponse:
        """
        Returns records from a sheet in a workbook

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet

            - version_id: typing.Optional[VersionId].

            - until_version_id: typing.Optional[VersionId].

            - since_version_id: typing.Optional[VersionId].

            - sort_field: typing.Optional[SortField].

            - sort_direction: typing.Optional[SortDirection].

            - filter: typing.Optional[Filter].

            - filter_field: typing.Optional[FilterField].

            - search_value: typing.Optional[SearchValue].

            - search_field: typing.Optional[SearchField].

            - page_size: typing.Optional[int]. Number of records to return in a page (default 1000 if pageNumber included)

            - page_number: typing.Optional[int]. Based on pageSize, which page of records to return

            - include_counts: typing.Optional[bool]. Include counts for the total records, valid records and records with errors

            - include_links: typing.Optional[bool]. If true, linked records will be included in the results. Defaults to false

            - include_messages: typing.Optional[bool]. Include error messages, defaults to false
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/records"
            ),
            params=remove_none_from_dict(
                {
                    "versionId": version_id,
                    "untilVersionId": until_version_id,
                    "sinceVersionId": since_version_id,
                    "sortField": sort_field,
                    "sortDirection": sort_direction,
                    "filter": filter,
                    "filterField": filter_field,
                    "searchValue": search_value,
                    "searchField": search_field,
                    "pageSize": page_size,
                    "pageNumber": page_number,
                    "includeCounts": include_counts,
                    "includeLinks": include_links,
                    "includeMessages": include_messages,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_records_deprecated(
        self, workbook_id: WorkbookId, sheet_id: SheetId, *, request: Records
    ) -> VersionResponse:
        """
        Updates existing records in a workbook sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet

            - request: Records.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/records"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VersionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_records_deprecated(
        self, workbook_id: WorkbookId, sheet_id: SheetId, *, request: typing.List[RecordData]
    ) -> RecordsResponse:
        """
        Adds records to a workbook sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet

            - request: typing.List[RecordData].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/records"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_records_deprecated(
        self,
        workbook_id: WorkbookId,
        sheet_id: SheetId,
        *,
        ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]] = None,
    ) -> Success:
        """
        Deletes records from a workbook sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet

            - ids: typing.Optional[typing.Union[RecordId, typing.List[RecordId]]]. The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/records"
            ),
            params=remove_none_from_dict({"ids": ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def validate_sheet_deprecated(self, workbook_id: WorkbookId, sheet_id: SheetId) -> Success:
        """
        Trigger data hooks and validation to run on a sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/validate"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Success, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_version_deprecated(self, workbook_id: WorkbookId, sheet_id: SheetId) -> VersionResponse:
        """
        Creates a new version of a workbook sheet

        Parameters:
            - workbook_id: WorkbookId. ID of workbook

            - sheet_id: SheetId. ID of sheet
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"workbooks/{workbook_id}/sheets/{sheet_id}/versions"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VersionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(Errors, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
