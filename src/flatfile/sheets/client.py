# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..commons.types.workbook_id import WorkbookId
from ..core.request_options import RequestOptions
from .types.list_sheets_response import ListSheetsResponse
from ..core.pydantic_utilities import parse_obj_as
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..commons.types.sheet_id import SheetId
from .types.sheet_response import SheetResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..commons.types.success import Success
from ..commons.errors.bad_request_error import BadRequestError
from ..commons.types.errors import Errors
from ..commons.errors.not_found_error import NotFoundError
from ..commons.types.commit_id import CommitId
from ..commons.types.version_id import VersionId
from ..commons.types.sort_field import SortField
from ..commons.types.sort_direction import SortDirection
from ..commons.types.filter import Filter
from ..commons.types.filter_field import FilterField
from ..commons.types.search_value import SearchValue
from ..commons.types.search_field import SearchField
from ..commons.types.record_id import RecordId
from .types.record_counts_response import RecordCountsResponse
from ..commits.types.list_commits_response import ListCommitsResponse
from .types.distinct import Distinct
from .types.field_key import FieldKey
from ..commons.types.page_size import PageSize
from ..commons.types.page_number import PageNumber
from .types.include_counts import IncludeCounts
from .types.cells_response import CellsResponse
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class SheetsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self, *, workbook_id: WorkbookId, request_options: typing.Optional[RequestOptions] = None
    ) -> ListSheetsResponse:
        """
        Returns sheets in a workbook

        Parameters
        ----------
        workbook_id : WorkbookId
            ID of workbook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListSheetsResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.list(
            workbook_id="us_wb_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "sheets",
            method="GET",
            params={
                "workbookId": workbook_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListSheetsResponse,
                    parse_obj_as(
                        type_=ListSheetsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None) -> SheetResponse:
        """
        Returns a sheet in a workbook

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SheetResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.get(
            sheet_id="us_sh_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SheetResponse,
                    parse_obj_as(
                        type_=SheetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Deletes a specific sheet from a workbook

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.delete(
            sheet_id="us_sh_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def validate(self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Trigger data hooks and validation to run on a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.validate(
            sheet_id="us_sh_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/validate",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_records_as_csv(
        self,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[str] = None,
        commit_id: typing.Optional[CommitId] = None,
        since_version_id: typing.Optional[VersionId] = None,
        since_commit_id: typing.Optional[CommitId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Returns records from a sheet in a workbook as a csv file

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        version_id : typing.Optional[str]
            Deprecated, use `sinceCommitId` instead.

        commit_id : typing.Optional[CommitId]
            Returns records that were changed in that version  in that version and only those records.

        since_version_id : typing.Optional[VersionId]
            Deprecated, use `sinceCommitId` instead.

        since_commit_id : typing.Optional[CommitId]
            Returns records that were changed in that version in addition to any records from versions after that version.

        sort_field : typing.Optional[SortField]
            The field to sort the data on.

        sort_direction : typing.Optional[SortDirection]
            Sort direction - asc (ascending) or desc (descending)

        filter : typing.Optional[Filter]
            Options to filter records

        filter_field : typing.Optional[FilterField]
            The field to filter the data on.

        search_value : typing.Optional[SearchValue]
            The value to search for data on.

        search_field : typing.Optional[SearchField]
            The field to search for data on.

        ids : typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]]
            The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.Iterator[bytes]
        """
        with self._client_wrapper.httpx_client.stream(
            f"sheets/{jsonable_encoder(sheet_id)}/download",
            method="GET",
            params={
                "versionId": version_id,
                "commitId": commit_id,
                "sinceVersionId": since_version_id,
                "sinceCommitId": since_commit_id,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "ids": ids,
            },
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                    for _chunk in _response.iter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                _response.read()
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_record_counts(
        self,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[str] = None,
        since_version_id: typing.Optional[VersionId] = None,
        commit_id: typing.Optional[CommitId] = None,
        since_commit_id: typing.Optional[CommitId] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        by_field: typing.Optional[bool] = None,
        q: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RecordCountsResponse:
        """
        Returns counts of records from a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        version_id : typing.Optional[str]
            Returns records that were changed in that version and only those records.

        since_version_id : typing.Optional[VersionId]
            Deprecated, use `sinceCommitId` instead.

        commit_id : typing.Optional[CommitId]
            Returns records that were changed in that version in addition to any records from versions after that version.

        since_commit_id : typing.Optional[CommitId]
            Listing a commit ID here will return all records since the specified commit.

        filter : typing.Optional[Filter]
            Options to filter records

        filter_field : typing.Optional[FilterField]
            The field to filter the data on.

        search_value : typing.Optional[SearchValue]
            The value to search for data on.

        search_field : typing.Optional[SearchField]
            The field to search for data on.

        by_field : typing.Optional[bool]
            If true, the counts for each field will also be returned

        q : typing.Optional[str]
            An FFQL query used to filter the result set to be counted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RecordCountsResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.get_record_counts(
            sheet_id="us_sh_YOUR_ID",
            version_id="us_vr_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/counts",
            method="GET",
            params={
                "versionId": version_id,
                "sinceVersionId": since_version_id,
                "commitId": commit_id,
                "sinceCommitId": since_commit_id,
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "byField": by_field,
                "q": q,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RecordCountsResponse,
                    parse_obj_as(
                        type_=RecordCountsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_sheet_commits(
        self,
        sheet_id: SheetId,
        *,
        completed: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListCommitsResponse:
        """
        Returns the commit versions for a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        completed : typing.Optional[bool]
            If true, only return commits that have been completed. If false, only return commits that have not been completed. If not provided, return all commits.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListCommitsResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.get_sheet_commits(
            sheet_id="us_sh_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/commits",
            method="GET",
            params={
                "completed": completed,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListCommitsResponse,
                    parse_obj_as(
                        type_=ListCommitsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def lock_sheet(self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Locks a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.lock_sheet(
            sheet_id="us_sh_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/lock",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def unlock_sheet(self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Removes a lock from a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.unlock_sheet(
            sheet_id="us_sh_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/unlock",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_cell_values(
        self,
        sheet_id: SheetId,
        *,
        distinct: Distinct,
        field_key: typing.Optional[FieldKey] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        page_size: typing.Optional[PageSize] = None,
        page_number: typing.Optional[PageNumber] = None,
        include_counts: typing.Optional[IncludeCounts] = None,
        search_value: typing.Optional[SearchValue] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CellsResponse:
        """
        Returns record cell values grouped by all fields in the sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        distinct : Distinct
            Must be set to true

        field_key : typing.Optional[FieldKey]

        sort_field : typing.Optional[SortField]

        sort_direction : typing.Optional[SortDirection]

        filter : typing.Optional[Filter]

        filter_field : typing.Optional[FilterField]
            Name of field by which to filter records

        page_size : typing.Optional[PageSize]
            Number of records to return in a page (default 1000 if pageNumber included)

        page_number : typing.Optional[PageNumber]
            Based on pageSize, which page of records to return

        include_counts : typing.Optional[IncludeCounts]

        search_value : typing.Optional[SearchValue]
            A value to find for a given field in a sheet. Wrap the value in "" for exact match

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CellsResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.get_cell_values(
            sheet_id="us_sh_YOUR_ID",
            distinct=True,
            field_key="firstName",
            sort_field="firstName",
            sort_direction="asc",
            filter="valid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/cells",
            method="GET",
            params={
                "fieldKey": field_key,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "filter": filter,
                "filterField": filter_field,
                "pageSize": page_size,
                "pageNumber": page_number,
                "distinct": distinct,
                "includeCounts": include_counts,
                "searchValue": search_value,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CellsResponse,
                    parse_obj_as(
                        type_=CellsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_sheet(
        self,
        sheet_id: SheetId,
        *,
        name: typing.Optional[str] = OMIT,
        slug: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SheetResponse:
        """
        Updates Sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        name : typing.Optional[str]
            The name of the Sheet.

        slug : typing.Optional[str]
            The slug of the Sheet.

        metadata : typing.Optional[typing.Optional[typing.Any]]
            Useful for any contextual metadata regarding the sheet. Store any valid json

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SheetResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.sheets.update_sheet(
            sheet_id="us_sh_YOUR_ID",
            name="New Sheet Name",
            metadata={"rowHeaders": [6]},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}",
            method="PATCH",
            json={
                "name": name,
                "slug": slug,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SheetResponse,
                    parse_obj_as(
                        type_=SheetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncSheetsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self, *, workbook_id: WorkbookId, request_options: typing.Optional[RequestOptions] = None
    ) -> ListSheetsResponse:
        """
        Returns sheets in a workbook

        Parameters
        ----------
        workbook_id : WorkbookId
            ID of workbook

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListSheetsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.list(
                workbook_id="us_wb_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sheets",
            method="GET",
            params={
                "workbookId": workbook_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListSheetsResponse,
                    parse_obj_as(
                        type_=ListSheetsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None) -> SheetResponse:
        """
        Returns a sheet in a workbook

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SheetResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.get(
                sheet_id="us_sh_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SheetResponse,
                    parse_obj_as(
                        type_=SheetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Deletes a specific sheet from a workbook

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.delete(
                sheet_id="us_sh_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def validate(self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Trigger data hooks and validation to run on a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.validate(
                sheet_id="us_sh_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/validate",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_records_as_csv(
        self,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[str] = None,
        commit_id: typing.Optional[CommitId] = None,
        since_version_id: typing.Optional[VersionId] = None,
        since_commit_id: typing.Optional[CommitId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Returns records from a sheet in a workbook as a csv file

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        version_id : typing.Optional[str]
            Deprecated, use `sinceCommitId` instead.

        commit_id : typing.Optional[CommitId]
            Returns records that were changed in that version  in that version and only those records.

        since_version_id : typing.Optional[VersionId]
            Deprecated, use `sinceCommitId` instead.

        since_commit_id : typing.Optional[CommitId]
            Returns records that were changed in that version in addition to any records from versions after that version.

        sort_field : typing.Optional[SortField]
            The field to sort the data on.

        sort_direction : typing.Optional[SortDirection]
            Sort direction - asc (ascending) or desc (descending)

        filter : typing.Optional[Filter]
            Options to filter records

        filter_field : typing.Optional[FilterField]
            The field to filter the data on.

        search_value : typing.Optional[SearchValue]
            The value to search for data on.

        search_field : typing.Optional[SearchField]
            The field to search for data on.

        ids : typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]]
            The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.AsyncIterator[bytes]
        """
        async with self._client_wrapper.httpx_client.stream(
            f"sheets/{jsonable_encoder(sheet_id)}/download",
            method="GET",
            params={
                "versionId": version_id,
                "commitId": commit_id,
                "sinceVersionId": since_version_id,
                "sinceCommitId": since_commit_id,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "ids": ids,
            },
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                    async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                await _response.aread()
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_record_counts(
        self,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[str] = None,
        since_version_id: typing.Optional[VersionId] = None,
        commit_id: typing.Optional[CommitId] = None,
        since_commit_id: typing.Optional[CommitId] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        by_field: typing.Optional[bool] = None,
        q: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RecordCountsResponse:
        """
        Returns counts of records from a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        version_id : typing.Optional[str]
            Returns records that were changed in that version and only those records.

        since_version_id : typing.Optional[VersionId]
            Deprecated, use `sinceCommitId` instead.

        commit_id : typing.Optional[CommitId]
            Returns records that were changed in that version in addition to any records from versions after that version.

        since_commit_id : typing.Optional[CommitId]
            Listing a commit ID here will return all records since the specified commit.

        filter : typing.Optional[Filter]
            Options to filter records

        filter_field : typing.Optional[FilterField]
            The field to filter the data on.

        search_value : typing.Optional[SearchValue]
            The value to search for data on.

        search_field : typing.Optional[SearchField]
            The field to search for data on.

        by_field : typing.Optional[bool]
            If true, the counts for each field will also be returned

        q : typing.Optional[str]
            An FFQL query used to filter the result set to be counted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RecordCountsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.get_record_counts(
                sheet_id="us_sh_YOUR_ID",
                version_id="us_vr_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/counts",
            method="GET",
            params={
                "versionId": version_id,
                "sinceVersionId": since_version_id,
                "commitId": commit_id,
                "sinceCommitId": since_commit_id,
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "byField": by_field,
                "q": q,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RecordCountsResponse,
                    parse_obj_as(
                        type_=RecordCountsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_sheet_commits(
        self,
        sheet_id: SheetId,
        *,
        completed: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListCommitsResponse:
        """
        Returns the commit versions for a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        completed : typing.Optional[bool]
            If true, only return commits that have been completed. If false, only return commits that have not been completed. If not provided, return all commits.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListCommitsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.get_sheet_commits(
                sheet_id="us_sh_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/commits",
            method="GET",
            params={
                "completed": completed,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListCommitsResponse,
                    parse_obj_as(
                        type_=ListCommitsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def lock_sheet(
        self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Success:
        """
        Locks a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.lock_sheet(
                sheet_id="us_sh_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/lock",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def unlock_sheet(
        self, sheet_id: SheetId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Success:
        """
        Removes a lock from a sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.unlock_sheet(
                sheet_id="us_sh_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/unlock",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_cell_values(
        self,
        sheet_id: SheetId,
        *,
        distinct: Distinct,
        field_key: typing.Optional[FieldKey] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        page_size: typing.Optional[PageSize] = None,
        page_number: typing.Optional[PageNumber] = None,
        include_counts: typing.Optional[IncludeCounts] = None,
        search_value: typing.Optional[SearchValue] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CellsResponse:
        """
        Returns record cell values grouped by all fields in the sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        distinct : Distinct
            Must be set to true

        field_key : typing.Optional[FieldKey]

        sort_field : typing.Optional[SortField]

        sort_direction : typing.Optional[SortDirection]

        filter : typing.Optional[Filter]

        filter_field : typing.Optional[FilterField]
            Name of field by which to filter records

        page_size : typing.Optional[PageSize]
            Number of records to return in a page (default 1000 if pageNumber included)

        page_number : typing.Optional[PageNumber]
            Based on pageSize, which page of records to return

        include_counts : typing.Optional[IncludeCounts]

        search_value : typing.Optional[SearchValue]
            A value to find for a given field in a sheet. Wrap the value in "" for exact match

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CellsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.get_cell_values(
                sheet_id="us_sh_YOUR_ID",
                distinct=True,
                field_key="firstName",
                sort_field="firstName",
                sort_direction="asc",
                filter="valid",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/cells",
            method="GET",
            params={
                "fieldKey": field_key,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "filter": filter,
                "filterField": filter_field,
                "pageSize": page_size,
                "pageNumber": page_number,
                "distinct": distinct,
                "includeCounts": include_counts,
                "searchValue": search_value,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CellsResponse,
                    parse_obj_as(
                        type_=CellsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_sheet(
        self,
        sheet_id: SheetId,
        *,
        name: typing.Optional[str] = OMIT,
        slug: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SheetResponse:
        """
        Updates Sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        name : typing.Optional[str]
            The name of the Sheet.

        slug : typing.Optional[str]
            The slug of the Sheet.

        metadata : typing.Optional[typing.Optional[typing.Any]]
            Useful for any contextual metadata regarding the sheet. Store any valid json

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SheetResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.sheets.update_sheet(
                sheet_id="us_sh_YOUR_ID",
                name="New Sheet Name",
                metadata={"rowHeaders": [6]},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}",
            method="PATCH",
            json={
                "name": name,
                "slug": slug,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SheetResponse,
                    parse_obj_as(
                        type_=SheetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
