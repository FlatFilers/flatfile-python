# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..commons.types.environment_id import EnvironmentId
from .types.get_spaces_sort_field import GetSpacesSortField
from ..commons.types.sort_direction import SortDirection
from ..commons.types.app_id import AppId
from ..core.request_options import RequestOptions
from .types.list_spaces_response import ListSpacesResponse
from ..core.pydantic_utilities import parse_obj_as
from ..commons.errors.bad_request_error import BadRequestError
from ..commons.types.errors import Errors
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..environments.types.guest_authentication_enum import GuestAuthenticationEnum
from ..commons.types.space_config_id import SpaceConfigId
from ..commons.types.workbook_id import WorkbookId
from .types.space_settings import SpaceSettings
from ..commons.types.action import Action
from .types.space_access import SpaceAccess
import datetime as dt
from .types.space_response import SpaceResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from ..commons.errors.not_found_error import NotFoundError
from ..commons.types.space_id import SpaceId
from ..core.jsonable_encoder import jsonable_encoder
from ..commons.types.success import Success
from .types.guidance_options import GuidanceOptions
from .types.guidance_resource import GuidanceResource
from ..commons.errors.forbidden_error import ForbiddenError
from .types.guidance_list_response import GuidanceListResponse
from ..commons.types.guidance_id import GuidanceId
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class SpacesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        environment_id: typing.Optional[EnvironmentId] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        search: typing.Optional[str] = None,
        namespace: typing.Optional[str] = None,
        archived: typing.Optional[bool] = None,
        sort_field: typing.Optional[GetSpacesSortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        is_collaborative: typing.Optional[bool] = None,
        app_id: typing.Optional[AppId] = None,
        is_app_template: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListSpacesResponse:
        """
        Returns all spaces for an account or environment

        Parameters
        ----------
        environment_id : typing.Optional[EnvironmentId]
            The ID of the environment.

        page_size : typing.Optional[int]
            Number of spaces to return in a page (default 10)

        page_number : typing.Optional[int]
            Based on pageSize, which page of records to return

        search : typing.Optional[str]
            Search query for spaces

        namespace : typing.Optional[str]
            Search by namespace

        archived : typing.Optional[bool]
            Flag to include archived spaces

        sort_field : typing.Optional[GetSpacesSortField]
            Field to sort spaces by; requires `sortDirection` if provided.

        sort_direction : typing.Optional[SortDirection]
            Direction of sorting; requires `sortField` if provided.

        is_collaborative : typing.Optional[bool]
            Flag for collaborative (project) spaces

        app_id : typing.Optional[AppId]
            Filter by appId

        is_app_template : typing.Optional[bool]
            Flag for app templates

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListSpacesResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.list(
            environment_id="us_env_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "spaces",
            method="GET",
            params={
                "environmentId": environment_id,
                "pageSize": page_size,
                "pageNumber": page_number,
                "search": search,
                "namespace": namespace,
                "archived": archived,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "isCollaborative": is_collaborative,
                "appId": app_id,
                "isAppTemplate": is_app_template,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListSpacesResponse,
                    parse_obj_as(
                        type_=ListSpacesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        name: typing.Optional[str] = OMIT,
        display_order: typing.Optional[int] = OMIT,
        guest_authentication: typing.Optional[typing.Sequence[GuestAuthenticationEnum]] = OMIT,
        space_config_id: typing.Optional[SpaceConfigId] = OMIT,
        environment_id: typing.Optional[EnvironmentId] = OMIT,
        primary_workbook_id: typing.Optional[WorkbookId] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        settings: typing.Optional[SpaceSettings] = OMIT,
        actions: typing.Optional[typing.Sequence[Action]] = OMIT,
        access: typing.Optional[typing.Sequence[SpaceAccess]] = OMIT,
        auto_configure: typing.Optional[bool] = OMIT,
        namespace: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        translations_path: typing.Optional[str] = OMIT,
        language_override: typing.Optional[str] = OMIT,
        archived_at: typing.Optional[dt.datetime] = OMIT,
        app_id: typing.Optional[AppId] = OMIT,
        is_app_template: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SpaceResponse:
        """
        Creates a new space based on an existing Space Config

        Parameters
        ----------
        name : typing.Optional[str]
            The name of the space

        display_order : typing.Optional[int]
            The display order

        guest_authentication : typing.Optional[typing.Sequence[GuestAuthenticationEnum]]

        space_config_id : typing.Optional[SpaceConfigId]

        environment_id : typing.Optional[EnvironmentId]

        primary_workbook_id : typing.Optional[WorkbookId]
            The ID of the primary workbook for the space. This should not be included in create space requests.

        metadata : typing.Optional[typing.Optional[typing.Any]]
            Metadata for the space

        settings : typing.Optional[SpaceSettings]
            The Space settings.

        actions : typing.Optional[typing.Sequence[Action]]

        access : typing.Optional[typing.Sequence[SpaceAccess]]

        auto_configure : typing.Optional[bool]

        namespace : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        translations_path : typing.Optional[str]

        language_override : typing.Optional[str]

        archived_at : typing.Optional[dt.datetime]
            Date when space was archived

        app_id : typing.Optional[AppId]
            The ID of the App that space is associated with

        is_app_template : typing.Optional[bool]
            Whether the space is an app template. Only one space per app can be an app template.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SpaceResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.create(
            name="My First Workbook",
            display_order=1,
            environment_id="us_env_YOUR_ID",
            primary_workbook_id="us_wb_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "spaces",
            method="POST",
            json={
                "name": name,
                "displayOrder": display_order,
                "guestAuthentication": guest_authentication,
                "spaceConfigId": space_config_id,
                "environmentId": environment_id,
                "primaryWorkbookId": primary_workbook_id,
                "metadata": metadata,
                "settings": convert_and_respect_annotation_metadata(
                    object_=settings, annotation=SpaceSettings, direction="write"
                ),
                "actions": convert_and_respect_annotation_metadata(
                    object_=actions, annotation=typing.Sequence[Action], direction="write"
                ),
                "access": access,
                "autoConfigure": auto_configure,
                "namespace": namespace,
                "labels": labels,
                "translationsPath": translations_path,
                "languageOverride": language_override,
                "archivedAt": archived_at,
                "appId": app_id,
                "isAppTemplate": is_app_template,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SpaceResponse,
                    parse_obj_as(
                        type_=SpaceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, space_id: SpaceId, *, request_options: typing.Optional[RequestOptions] = None) -> SpaceResponse:
        """
        Returns a single space

        Parameters
        ----------
        space_id : SpaceId
            ID of space to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SpaceResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.get(
            space_id="us_sp_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SpaceResponse,
                    parse_obj_as(
                        type_=SpaceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, space_id: SpaceId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Delete a space

        Parameters
        ----------
        space_id : SpaceId
            ID of space to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.delete(
            space_id="us_sp_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def bulk_delete(
        self,
        *,
        space_ids: typing.Union[SpaceId, typing.Sequence[SpaceId]],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Success:
        """
        Delete multiple spaces by id

        Parameters
        ----------
        space_ids : typing.Union[SpaceId, typing.Sequence[SpaceId]]
            List of ids for the spaces to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.bulk_delete(
            space_ids="us_sp_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "spaces",
            method="DELETE",
            params={
                "spaceIds": space_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        space_id: SpaceId,
        *,
        name: typing.Optional[str] = OMIT,
        display_order: typing.Optional[int] = OMIT,
        guest_authentication: typing.Optional[typing.Sequence[GuestAuthenticationEnum]] = OMIT,
        space_config_id: typing.Optional[SpaceConfigId] = OMIT,
        environment_id: typing.Optional[EnvironmentId] = OMIT,
        primary_workbook_id: typing.Optional[WorkbookId] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        settings: typing.Optional[SpaceSettings] = OMIT,
        actions: typing.Optional[typing.Sequence[Action]] = OMIT,
        access: typing.Optional[typing.Sequence[SpaceAccess]] = OMIT,
        auto_configure: typing.Optional[bool] = OMIT,
        namespace: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        translations_path: typing.Optional[str] = OMIT,
        language_override: typing.Optional[str] = OMIT,
        archived_at: typing.Optional[dt.datetime] = OMIT,
        app_id: typing.Optional[AppId] = OMIT,
        is_app_template: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SpaceResponse:
        """
        Update a space, to change the name for example

        Parameters
        ----------
        space_id : SpaceId
            ID of space to update

        name : typing.Optional[str]
            The name of the space

        display_order : typing.Optional[int]
            The display order

        guest_authentication : typing.Optional[typing.Sequence[GuestAuthenticationEnum]]

        space_config_id : typing.Optional[SpaceConfigId]

        environment_id : typing.Optional[EnvironmentId]

        primary_workbook_id : typing.Optional[WorkbookId]
            The ID of the primary workbook for the space. This should not be included in create space requests.

        metadata : typing.Optional[typing.Optional[typing.Any]]
            Metadata for the space

        settings : typing.Optional[SpaceSettings]
            The Space settings.

        actions : typing.Optional[typing.Sequence[Action]]

        access : typing.Optional[typing.Sequence[SpaceAccess]]

        auto_configure : typing.Optional[bool]

        namespace : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        translations_path : typing.Optional[str]

        language_override : typing.Optional[str]

        archived_at : typing.Optional[dt.datetime]
            Date when space was archived

        app_id : typing.Optional[AppId]
            The ID of the App that space is associated with

        is_app_template : typing.Optional[bool]
            Whether the space is an app template. Only one space per app can be an app template.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SpaceResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.update(
            space_id="us_sp_YOUR_ID",
            name="My Updated Worbook",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}",
            method="PATCH",
            json={
                "name": name,
                "displayOrder": display_order,
                "guestAuthentication": guest_authentication,
                "spaceConfigId": space_config_id,
                "environmentId": environment_id,
                "primaryWorkbookId": primary_workbook_id,
                "metadata": metadata,
                "settings": convert_and_respect_annotation_metadata(
                    object_=settings, annotation=SpaceSettings, direction="write"
                ),
                "actions": convert_and_respect_annotation_metadata(
                    object_=actions, annotation=typing.Sequence[Action], direction="write"
                ),
                "access": access,
                "autoConfigure": auto_configure,
                "namespace": namespace,
                "labels": labels,
                "translationsPath": translations_path,
                "languageOverride": language_override,
                "archivedAt": archived_at,
                "appId": app_id,
                "isAppTemplate": is_app_template,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SpaceResponse,
                    parse_obj_as(
                        type_=SpaceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def archive_space(self, space_id: SpaceId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Sets archivedAt timestamp on a space

        Parameters
        ----------
        space_id : SpaceId
            ID of space to archive

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.archive_space(
            space_id="us_sp_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def unarchive_space(self, space_id: SpaceId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Sets archivedAt timestamp on a space to null

        Parameters
        ----------
        space_id : SpaceId
            ID of space to unarchive

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.unarchive_space(
            space_id="us_sp_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_guidance(
        self,
        space_id: SpaceId,
        *,
        guide_slug: str,
        options: GuidanceOptions,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuidanceResource:
        """
        Creates a new guidance

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guide_slug : str

        options : GuidanceOptions
            Options for the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuidanceResource

        Examples
        --------
        from flatfile import Flatfile
        from flatfile.spaces import GuidanceOptions

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.create_guidance(
            space_id="spaceId",
            guide_slug="guideSlug",
            options=GuidanceOptions(
                target="target",
                trigger="first",
                type="sidebar",
                role="admin",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance",
            method="POST",
            json={
                "guideSlug": guide_slug,
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=GuidanceOptions, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuidanceResource,
                    parse_obj_as(
                        type_=GuidanceResource,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_guidance(
        self,
        space_id: SpaceId,
        *,
        guide: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuidanceListResponse:
        """
        Lists guidances

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guide : typing.Optional[str]
            Include the guide with the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuidanceListResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.list_guidance(
            space_id="spaceId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance",
            method="GET",
            params={
                "guide": guide,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuidanceListResponse,
                    parse_obj_as(
                        type_=GuidanceListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_guidance(
        self,
        space_id: SpaceId,
        guidance_id: GuidanceId,
        *,
        guide: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuidanceResource:
        """
        Retrieves a guidance by its id

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guidance_id : GuidanceId
            ID of the guidance

        guide : typing.Optional[str]
            Include the guide with the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuidanceResource

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.get_guidance(
            space_id="spaceId",
            guidance_id="guidanceId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance/{jsonable_encoder(guidance_id)}",
            method="GET",
            params={
                "guide": guide,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuidanceResource,
                    parse_obj_as(
                        type_=GuidanceResource,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_guidance(
        self,
        space_id: SpaceId,
        guidance_id: GuidanceId,
        *,
        options: GuidanceOptions,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuidanceResource:
        """
        Updates a guidance with the given id

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guidance_id : GuidanceId
            ID of the guidance

        options : GuidanceOptions
            Options for the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuidanceResource

        Examples
        --------
        from flatfile import Flatfile
        from flatfile.spaces import GuidanceOptions

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.update_guidance(
            space_id="spaceId",
            guidance_id="guidanceId",
            options=GuidanceOptions(
                target="target",
                trigger="first",
                type="sidebar",
                role="admin",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance/{jsonable_encoder(guidance_id)}",
            method="PATCH",
            json={
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=GuidanceOptions, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuidanceResource,
                    parse_obj_as(
                        type_=GuidanceResource,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_guidance(
        self, space_id: SpaceId, guidance_id: GuidanceId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Success:
        """
        Deletes a guidance by its id

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guidance_id : GuidanceId
            ID of the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.spaces.delete_guidance(
            space_id="spaceId",
            guidance_id="guidanceId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance/{jsonable_encoder(guidance_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncSpacesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        environment_id: typing.Optional[EnvironmentId] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        search: typing.Optional[str] = None,
        namespace: typing.Optional[str] = None,
        archived: typing.Optional[bool] = None,
        sort_field: typing.Optional[GetSpacesSortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        is_collaborative: typing.Optional[bool] = None,
        app_id: typing.Optional[AppId] = None,
        is_app_template: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListSpacesResponse:
        """
        Returns all spaces for an account or environment

        Parameters
        ----------
        environment_id : typing.Optional[EnvironmentId]
            The ID of the environment.

        page_size : typing.Optional[int]
            Number of spaces to return in a page (default 10)

        page_number : typing.Optional[int]
            Based on pageSize, which page of records to return

        search : typing.Optional[str]
            Search query for spaces

        namespace : typing.Optional[str]
            Search by namespace

        archived : typing.Optional[bool]
            Flag to include archived spaces

        sort_field : typing.Optional[GetSpacesSortField]
            Field to sort spaces by; requires `sortDirection` if provided.

        sort_direction : typing.Optional[SortDirection]
            Direction of sorting; requires `sortField` if provided.

        is_collaborative : typing.Optional[bool]
            Flag for collaborative (project) spaces

        app_id : typing.Optional[AppId]
            Filter by appId

        is_app_template : typing.Optional[bool]
            Flag for app templates

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListSpacesResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.list(
                environment_id="us_env_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "spaces",
            method="GET",
            params={
                "environmentId": environment_id,
                "pageSize": page_size,
                "pageNumber": page_number,
                "search": search,
                "namespace": namespace,
                "archived": archived,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "isCollaborative": is_collaborative,
                "appId": app_id,
                "isAppTemplate": is_app_template,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListSpacesResponse,
                    parse_obj_as(
                        type_=ListSpacesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        name: typing.Optional[str] = OMIT,
        display_order: typing.Optional[int] = OMIT,
        guest_authentication: typing.Optional[typing.Sequence[GuestAuthenticationEnum]] = OMIT,
        space_config_id: typing.Optional[SpaceConfigId] = OMIT,
        environment_id: typing.Optional[EnvironmentId] = OMIT,
        primary_workbook_id: typing.Optional[WorkbookId] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        settings: typing.Optional[SpaceSettings] = OMIT,
        actions: typing.Optional[typing.Sequence[Action]] = OMIT,
        access: typing.Optional[typing.Sequence[SpaceAccess]] = OMIT,
        auto_configure: typing.Optional[bool] = OMIT,
        namespace: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        translations_path: typing.Optional[str] = OMIT,
        language_override: typing.Optional[str] = OMIT,
        archived_at: typing.Optional[dt.datetime] = OMIT,
        app_id: typing.Optional[AppId] = OMIT,
        is_app_template: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SpaceResponse:
        """
        Creates a new space based on an existing Space Config

        Parameters
        ----------
        name : typing.Optional[str]
            The name of the space

        display_order : typing.Optional[int]
            The display order

        guest_authentication : typing.Optional[typing.Sequence[GuestAuthenticationEnum]]

        space_config_id : typing.Optional[SpaceConfigId]

        environment_id : typing.Optional[EnvironmentId]

        primary_workbook_id : typing.Optional[WorkbookId]
            The ID of the primary workbook for the space. This should not be included in create space requests.

        metadata : typing.Optional[typing.Optional[typing.Any]]
            Metadata for the space

        settings : typing.Optional[SpaceSettings]
            The Space settings.

        actions : typing.Optional[typing.Sequence[Action]]

        access : typing.Optional[typing.Sequence[SpaceAccess]]

        auto_configure : typing.Optional[bool]

        namespace : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        translations_path : typing.Optional[str]

        language_override : typing.Optional[str]

        archived_at : typing.Optional[dt.datetime]
            Date when space was archived

        app_id : typing.Optional[AppId]
            The ID of the App that space is associated with

        is_app_template : typing.Optional[bool]
            Whether the space is an app template. Only one space per app can be an app template.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SpaceResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.create(
                name="My First Workbook",
                display_order=1,
                environment_id="us_env_YOUR_ID",
                primary_workbook_id="us_wb_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "spaces",
            method="POST",
            json={
                "name": name,
                "displayOrder": display_order,
                "guestAuthentication": guest_authentication,
                "spaceConfigId": space_config_id,
                "environmentId": environment_id,
                "primaryWorkbookId": primary_workbook_id,
                "metadata": metadata,
                "settings": convert_and_respect_annotation_metadata(
                    object_=settings, annotation=SpaceSettings, direction="write"
                ),
                "actions": convert_and_respect_annotation_metadata(
                    object_=actions, annotation=typing.Sequence[Action], direction="write"
                ),
                "access": access,
                "autoConfigure": auto_configure,
                "namespace": namespace,
                "labels": labels,
                "translationsPath": translations_path,
                "languageOverride": language_override,
                "archivedAt": archived_at,
                "appId": app_id,
                "isAppTemplate": is_app_template,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SpaceResponse,
                    parse_obj_as(
                        type_=SpaceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, space_id: SpaceId, *, request_options: typing.Optional[RequestOptions] = None) -> SpaceResponse:
        """
        Returns a single space

        Parameters
        ----------
        space_id : SpaceId
            ID of space to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SpaceResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.get(
                space_id="us_sp_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SpaceResponse,
                    parse_obj_as(
                        type_=SpaceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, space_id: SpaceId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Delete a space

        Parameters
        ----------
        space_id : SpaceId
            ID of space to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.delete(
                space_id="us_sp_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def bulk_delete(
        self,
        *,
        space_ids: typing.Union[SpaceId, typing.Sequence[SpaceId]],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Success:
        """
        Delete multiple spaces by id

        Parameters
        ----------
        space_ids : typing.Union[SpaceId, typing.Sequence[SpaceId]]
            List of ids for the spaces to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.bulk_delete(
                space_ids="us_sp_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "spaces",
            method="DELETE",
            params={
                "spaceIds": space_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        space_id: SpaceId,
        *,
        name: typing.Optional[str] = OMIT,
        display_order: typing.Optional[int] = OMIT,
        guest_authentication: typing.Optional[typing.Sequence[GuestAuthenticationEnum]] = OMIT,
        space_config_id: typing.Optional[SpaceConfigId] = OMIT,
        environment_id: typing.Optional[EnvironmentId] = OMIT,
        primary_workbook_id: typing.Optional[WorkbookId] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        settings: typing.Optional[SpaceSettings] = OMIT,
        actions: typing.Optional[typing.Sequence[Action]] = OMIT,
        access: typing.Optional[typing.Sequence[SpaceAccess]] = OMIT,
        auto_configure: typing.Optional[bool] = OMIT,
        namespace: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        translations_path: typing.Optional[str] = OMIT,
        language_override: typing.Optional[str] = OMIT,
        archived_at: typing.Optional[dt.datetime] = OMIT,
        app_id: typing.Optional[AppId] = OMIT,
        is_app_template: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SpaceResponse:
        """
        Update a space, to change the name for example

        Parameters
        ----------
        space_id : SpaceId
            ID of space to update

        name : typing.Optional[str]
            The name of the space

        display_order : typing.Optional[int]
            The display order

        guest_authentication : typing.Optional[typing.Sequence[GuestAuthenticationEnum]]

        space_config_id : typing.Optional[SpaceConfigId]

        environment_id : typing.Optional[EnvironmentId]

        primary_workbook_id : typing.Optional[WorkbookId]
            The ID of the primary workbook for the space. This should not be included in create space requests.

        metadata : typing.Optional[typing.Optional[typing.Any]]
            Metadata for the space

        settings : typing.Optional[SpaceSettings]
            The Space settings.

        actions : typing.Optional[typing.Sequence[Action]]

        access : typing.Optional[typing.Sequence[SpaceAccess]]

        auto_configure : typing.Optional[bool]

        namespace : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        translations_path : typing.Optional[str]

        language_override : typing.Optional[str]

        archived_at : typing.Optional[dt.datetime]
            Date when space was archived

        app_id : typing.Optional[AppId]
            The ID of the App that space is associated with

        is_app_template : typing.Optional[bool]
            Whether the space is an app template. Only one space per app can be an app template.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SpaceResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.update(
                space_id="us_sp_YOUR_ID",
                name="My Updated Worbook",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}",
            method="PATCH",
            json={
                "name": name,
                "displayOrder": display_order,
                "guestAuthentication": guest_authentication,
                "spaceConfigId": space_config_id,
                "environmentId": environment_id,
                "primaryWorkbookId": primary_workbook_id,
                "metadata": metadata,
                "settings": convert_and_respect_annotation_metadata(
                    object_=settings, annotation=SpaceSettings, direction="write"
                ),
                "actions": convert_and_respect_annotation_metadata(
                    object_=actions, annotation=typing.Sequence[Action], direction="write"
                ),
                "access": access,
                "autoConfigure": auto_configure,
                "namespace": namespace,
                "labels": labels,
                "translationsPath": translations_path,
                "languageOverride": language_override,
                "archivedAt": archived_at,
                "appId": app_id,
                "isAppTemplate": is_app_template,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SpaceResponse,
                    parse_obj_as(
                        type_=SpaceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def archive_space(
        self, space_id: SpaceId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Success:
        """
        Sets archivedAt timestamp on a space

        Parameters
        ----------
        space_id : SpaceId
            ID of space to archive

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.archive_space(
                space_id="us_sp_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/archive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def unarchive_space(
        self, space_id: SpaceId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Success:
        """
        Sets archivedAt timestamp on a space to null

        Parameters
        ----------
        space_id : SpaceId
            ID of space to unarchive

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.unarchive_space(
                space_id="us_sp_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/unarchive",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_guidance(
        self,
        space_id: SpaceId,
        *,
        guide_slug: str,
        options: GuidanceOptions,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuidanceResource:
        """
        Creates a new guidance

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guide_slug : str

        options : GuidanceOptions
            Options for the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuidanceResource

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile
        from flatfile.spaces import GuidanceOptions

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.create_guidance(
                space_id="spaceId",
                guide_slug="guideSlug",
                options=GuidanceOptions(
                    target="target",
                    trigger="first",
                    type="sidebar",
                    role="admin",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance",
            method="POST",
            json={
                "guideSlug": guide_slug,
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=GuidanceOptions, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuidanceResource,
                    parse_obj_as(
                        type_=GuidanceResource,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_guidance(
        self,
        space_id: SpaceId,
        *,
        guide: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuidanceListResponse:
        """
        Lists guidances

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guide : typing.Optional[str]
            Include the guide with the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuidanceListResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.list_guidance(
                space_id="spaceId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance",
            method="GET",
            params={
                "guide": guide,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuidanceListResponse,
                    parse_obj_as(
                        type_=GuidanceListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_guidance(
        self,
        space_id: SpaceId,
        guidance_id: GuidanceId,
        *,
        guide: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuidanceResource:
        """
        Retrieves a guidance by its id

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guidance_id : GuidanceId
            ID of the guidance

        guide : typing.Optional[str]
            Include the guide with the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuidanceResource

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.get_guidance(
                space_id="spaceId",
                guidance_id="guidanceId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance/{jsonable_encoder(guidance_id)}",
            method="GET",
            params={
                "guide": guide,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuidanceResource,
                    parse_obj_as(
                        type_=GuidanceResource,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_guidance(
        self,
        space_id: SpaceId,
        guidance_id: GuidanceId,
        *,
        options: GuidanceOptions,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuidanceResource:
        """
        Updates a guidance with the given id

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guidance_id : GuidanceId
            ID of the guidance

        options : GuidanceOptions
            Options for the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuidanceResource

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile
        from flatfile.spaces import GuidanceOptions

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.update_guidance(
                space_id="spaceId",
                guidance_id="guidanceId",
                options=GuidanceOptions(
                    target="target",
                    trigger="first",
                    type="sidebar",
                    role="admin",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance/{jsonable_encoder(guidance_id)}",
            method="PATCH",
            json={
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=GuidanceOptions, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuidanceResource,
                    parse_obj_as(
                        type_=GuidanceResource,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_guidance(
        self, space_id: SpaceId, guidance_id: GuidanceId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Success:
        """
        Deletes a guidance by its id

        Parameters
        ----------
        space_id : SpaceId
            ID of the space

        guidance_id : GuidanceId
            ID of the guidance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.spaces.delete_guidance(
                space_id="spaceId",
                guidance_id="guidanceId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"spaces/{jsonable_encoder(space_id)}/guidance/{jsonable_encoder(guidance_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
