# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.list_users_sort_field import ListUsersSortField
from ..commons.types.sort_direction import SortDirection
from ..core.request_options import RequestOptions
from .types.list_users_response import ListUsersResponse
from ..core.pydantic_utilities import parse_obj_as
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..roles.types.assign_actor_role_request import AssignActorRoleRequest
from .types.user_with_roles_response import UserWithRolesResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from ..commons.types.user_id import UserId
from ..commons.types.success import Success
from ..core.jsonable_encoder import jsonable_encoder
from .types.user_response import UserResponse
from ..roles.types.list_actor_roles_response import ListActorRolesResponse
from ..commons.errors.bad_request_error import BadRequestError
from ..commons.types.errors import Errors
from ..commons.errors.not_found_error import NotFoundError
from ..commons.errors.forbidden_error import ForbiddenError
from ..commons.types.role_id import RoleId
from ..roles.types.resource_id_union import ResourceIdUnion
from ..roles.types.assign_role_response import AssignRoleResponse
from ..commons.types.actor_role_id import ActorRoleId
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class UsersClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        email: typing.Optional[str] = None,
        search: typing.Optional[str] = None,
        sort_field: typing.Optional[ListUsersSortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListUsersResponse:
        """
        Gets a list of users

        Parameters
        ----------
        email : typing.Optional[str]
            Email of guest to return

        search : typing.Optional[str]
            String to search for users by name and email

        sort_field : typing.Optional[ListUsersSortField]
            Field to sort users by

        sort_direction : typing.Optional[SortDirection]
            Direction of sorting

        page_size : typing.Optional[int]
            Number of users to return in a page (default 20)

        page_number : typing.Optional[int]
            Based on pageSize, which page of users to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListUsersResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.users.list(
            email="john.smith@example.com",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "users",
            method="GET",
            params={
                "email": email,
                "search": search,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "pageSize": page_size,
                "pageNumber": page_number,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListUsersResponse,
                    parse_obj_as(
                        type_=ListUsersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_and_invite(
        self,
        *,
        email: str,
        name: str,
        actor_roles: typing.Sequence[AssignActorRoleRequest],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserWithRolesResponse:
        """
        Creates and invites a new user to your account.

        Parameters
        ----------
        email : str

        name : str

        actor_roles : typing.Sequence[AssignActorRoleRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserWithRolesResponse

        Examples
        --------
        from flatfile import Flatfile
        from flatfile.roles import AssignActorRoleRequest

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.users.create_and_invite(
            email="john.smith@example.com",
            name="John Smith",
            actor_roles=[
                AssignActorRoleRequest(
                    role_id="us_rol_YOUR_ID",
                    resource_id="us_acc_YOUR_ID",
                ),
                AssignActorRoleRequest(
                    role_id="us_rol_YOUR_ID",
                    resource_id="us_env_YOUR_ID",
                ),
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "users/invite",
            method="POST",
            json={
                "email": email,
                "name": name,
                "actorRoles": convert_and_respect_annotation_metadata(
                    object_=actor_roles, annotation=typing.Sequence[AssignActorRoleRequest], direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UserWithRolesResponse,
                    parse_obj_as(
                        type_=UserWithRolesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def resend_invite(self, user_id: UserId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Resends an invite to a user for your account.

        Parameters
        ----------
        user_id : UserId
            The user id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.users.resend_invite(
            user_id="userId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}/resend-invite",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        user_id: UserId,
        *,
        name: typing.Optional[str] = OMIT,
        dashboard: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserResponse:
        """
        Updates a user

        Parameters
        ----------
        user_id : UserId
            The user id

        name : typing.Optional[str]

        dashboard : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.users.update(
            user_id="userId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}",
            method="PATCH",
            json={
                "name": name,
                "dashboard": dashboard,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UserResponse,
                    parse_obj_as(
                        type_=UserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, user_id: UserId, *, request_options: typing.Optional[RequestOptions] = None) -> UserResponse:
        """
        Gets a user

        Parameters
        ----------
        user_id : UserId
            The user id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.users.get(
            user_id="us_usr_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UserResponse,
                    parse_obj_as(
                        type_=UserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, user_id: UserId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Deletes a user

        Parameters
        ----------
        user_id : UserId
            The user id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.users.delete(
            user_id="userId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_user_roles(
        self, user_id: UserId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ListActorRolesResponse:
        """
        Lists roles assigned to a user.

        Parameters
        ----------
        user_id : UserId
            The user id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListActorRolesResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.users.list_user_roles(
            user_id="userId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}/roles",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListActorRolesResponse,
                    parse_obj_as(
                        type_=ListActorRolesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def assign_user_role(
        self,
        user_id: UserId,
        *,
        role_id: RoleId,
        resource_id: ResourceIdUnion,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AssignRoleResponse:
        """
        Assigns a role to a user.

        Parameters
        ----------
        user_id : UserId
            The user id

        role_id : RoleId

        resource_id : ResourceIdUnion

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AssignRoleResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.users.assign_user_role(
            user_id="userId",
            role_id="roleId",
            resource_id="resourceId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}/roles",
            method="POST",
            json={
                "roleId": role_id,
                "resourceId": convert_and_respect_annotation_metadata(
                    object_=resource_id, annotation=ResourceIdUnion, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AssignRoleResponse,
                    parse_obj_as(
                        type_=AssignRoleResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_user_role(
        self, user_id: UserId, actor_role_id: ActorRoleId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Success:
        """
        Removes a role from a user.

        Parameters
        ----------
        user_id : UserId
            The user id

        actor_role_id : ActorRoleId
            The actor role id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.users.delete_user_role(
            user_id="userId",
            actor_role_id="actorRoleId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}/roles/{jsonable_encoder(actor_role_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncUsersClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        email: typing.Optional[str] = None,
        search: typing.Optional[str] = None,
        sort_field: typing.Optional[ListUsersSortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListUsersResponse:
        """
        Gets a list of users

        Parameters
        ----------
        email : typing.Optional[str]
            Email of guest to return

        search : typing.Optional[str]
            String to search for users by name and email

        sort_field : typing.Optional[ListUsersSortField]
            Field to sort users by

        sort_direction : typing.Optional[SortDirection]
            Direction of sorting

        page_size : typing.Optional[int]
            Number of users to return in a page (default 20)

        page_number : typing.Optional[int]
            Based on pageSize, which page of users to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListUsersResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.users.list(
                email="john.smith@example.com",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "users",
            method="GET",
            params={
                "email": email,
                "search": search,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "pageSize": page_size,
                "pageNumber": page_number,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListUsersResponse,
                    parse_obj_as(
                        type_=ListUsersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_and_invite(
        self,
        *,
        email: str,
        name: str,
        actor_roles: typing.Sequence[AssignActorRoleRequest],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserWithRolesResponse:
        """
        Creates and invites a new user to your account.

        Parameters
        ----------
        email : str

        name : str

        actor_roles : typing.Sequence[AssignActorRoleRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserWithRolesResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile
        from flatfile.roles import AssignActorRoleRequest

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.users.create_and_invite(
                email="john.smith@example.com",
                name="John Smith",
                actor_roles=[
                    AssignActorRoleRequest(
                        role_id="us_rol_YOUR_ID",
                        resource_id="us_acc_YOUR_ID",
                    ),
                    AssignActorRoleRequest(
                        role_id="us_rol_YOUR_ID",
                        resource_id="us_env_YOUR_ID",
                    ),
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "users/invite",
            method="POST",
            json={
                "email": email,
                "name": name,
                "actorRoles": convert_and_respect_annotation_metadata(
                    object_=actor_roles, annotation=typing.Sequence[AssignActorRoleRequest], direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UserWithRolesResponse,
                    parse_obj_as(
                        type_=UserWithRolesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def resend_invite(
        self, user_id: UserId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Success:
        """
        Resends an invite to a user for your account.

        Parameters
        ----------
        user_id : UserId
            The user id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.users.resend_invite(
                user_id="userId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}/resend-invite",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        user_id: UserId,
        *,
        name: typing.Optional[str] = OMIT,
        dashboard: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserResponse:
        """
        Updates a user

        Parameters
        ----------
        user_id : UserId
            The user id

        name : typing.Optional[str]

        dashboard : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.users.update(
                user_id="userId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}",
            method="PATCH",
            json={
                "name": name,
                "dashboard": dashboard,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UserResponse,
                    parse_obj_as(
                        type_=UserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, user_id: UserId, *, request_options: typing.Optional[RequestOptions] = None) -> UserResponse:
        """
        Gets a user

        Parameters
        ----------
        user_id : UserId
            The user id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.users.get(
                user_id="us_usr_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UserResponse,
                    parse_obj_as(
                        type_=UserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, user_id: UserId, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Deletes a user

        Parameters
        ----------
        user_id : UserId
            The user id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.users.delete(
                user_id="userId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_user_roles(
        self, user_id: UserId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ListActorRolesResponse:
        """
        Lists roles assigned to a user.

        Parameters
        ----------
        user_id : UserId
            The user id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListActorRolesResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.users.list_user_roles(
                user_id="userId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}/roles",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListActorRolesResponse,
                    parse_obj_as(
                        type_=ListActorRolesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def assign_user_role(
        self,
        user_id: UserId,
        *,
        role_id: RoleId,
        resource_id: ResourceIdUnion,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AssignRoleResponse:
        """
        Assigns a role to a user.

        Parameters
        ----------
        user_id : UserId
            The user id

        role_id : RoleId

        resource_id : ResourceIdUnion

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AssignRoleResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.users.assign_user_role(
                user_id="userId",
                role_id="roleId",
                resource_id="resourceId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}/roles",
            method="POST",
            json={
                "roleId": role_id,
                "resourceId": convert_and_respect_annotation_metadata(
                    object_=resource_id, annotation=ResourceIdUnion, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AssignRoleResponse,
                    parse_obj_as(
                        type_=AssignRoleResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_user_role(
        self, user_id: UserId, actor_role_id: ActorRoleId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Success:
        """
        Removes a role from a user.

        Parameters
        ----------
        user_id : UserId
            The user id

        actor_role_id : ActorRoleId
            The actor role id

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.users.delete_user_role(
                user_id="userId",
                actor_role_id="actorRoleId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(user_id)}/roles/{jsonable_encoder(actor_role_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
