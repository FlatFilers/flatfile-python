# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from .types.list_environments_response import ListEnvironmentsResponse
from ..core.pydantic_utilities import parse_obj_as
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.guest_authentication_enum import GuestAuthenticationEnum
from .types.environment_response import EnvironmentResponse
from ..commons.types.environment_id import EnvironmentId
from ..spaces.types.event_token_response import EventTokenResponse
from ..commons.errors.bad_request_error import BadRequestError
from ..commons.types.errors import Errors
from ..commons.errors.not_found_error import NotFoundError
from ..core.jsonable_encoder import jsonable_encoder
from .types.environment import Environment
from ..commons.types.success import Success
from .types.guide_list_response import GuideListResponse
from ..commons.types.guide_id import GuideId
from .types.guide_detail_response import GuideDetailResponse
from .types.guide_version_resource import GuideVersionResource
from ..core.serialization import convert_and_respect_annotation_metadata
from .types.guide_delete_response import GuideDeleteResponse
from .types.guide_version_response import GuideVersionResponse
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class EnvironmentsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListEnvironmentsResponse:
        """
        Get all environments

        Parameters
        ----------
        page_size : typing.Optional[int]
            Number of environments to return in a page (default 10)

        page_number : typing.Optional[int]
            Based on pageSize, which page of environments to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListEnvironmentsResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "environments",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListEnvironmentsResponse,
                    parse_obj_as(
                        type_=ListEnvironmentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        name: str,
        is_prod: bool,
        guest_authentication: typing.Optional[typing.Sequence[GuestAuthenticationEnum]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        translations_path: typing.Optional[str] = OMIT,
        namespaces: typing.Optional[typing.Sequence[str]] = OMIT,
        language_override: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EnvironmentResponse:
        """
        Create a new environment

        Parameters
        ----------
        name : str
            The name of the environment

        is_prod : bool
            Whether or not the environment is a production environment

        guest_authentication : typing.Optional[typing.Sequence[GuestAuthenticationEnum]]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        translations_path : typing.Optional[str]

        namespaces : typing.Optional[typing.Sequence[str]]

        language_override : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EnvironmentResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.create(
            name="dev",
            is_prod=False,
            guest_authentication=["magic_link"],
            metadata={"key": "value"},
            namespaces=["default"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "environments",
            method="POST",
            json={
                "name": name,
                "isProd": is_prod,
                "guestAuthentication": guest_authentication,
                "metadata": metadata,
                "translationsPath": translations_path,
                "namespaces": namespaces,
                "languageOverride": language_override,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EnvironmentResponse,
                    parse_obj_as(
                        type_=EnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_environment_event_token(
        self, *, environment_id: EnvironmentId, request_options: typing.Optional[RequestOptions] = None
    ) -> EventTokenResponse:
        """
        Get a token which can be used to subscribe to events for this environment

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of environment to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EventTokenResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.get_environment_event_token(
            environment_id="us_env_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "environments/subscription-token",
            method="GET",
            params={
                "environmentId": environment_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EventTokenResponse,
                    parse_obj_as(
                        type_=EventTokenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EnvironmentResponse:
        """
        Returns a single environment

        Parameters
        ----------
        environment_id : str
            ID of the environment to return. To fetch the current environment, pass `current`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EnvironmentResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.get(
            environment_id="us_env_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EnvironmentResponse,
                    parse_obj_as(
                        type_=EnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        environment_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        is_prod: typing.Optional[bool] = OMIT,
        guest_authentication: typing.Optional[typing.Sequence[GuestAuthenticationEnum]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        translations_path: typing.Optional[str] = OMIT,
        namespaces: typing.Optional[typing.Sequence[str]] = OMIT,
        language_override: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Environment:
        """
        Updates a single environment, to change the name for example

        Parameters
        ----------
        environment_id : str
            ID of the environment to update

        name : typing.Optional[str]
            The name of the environment

        is_prod : typing.Optional[bool]
            Whether or not the environment is a production environment

        guest_authentication : typing.Optional[typing.Sequence[GuestAuthenticationEnum]]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        translations_path : typing.Optional[str]

        namespaces : typing.Optional[typing.Sequence[str]]

        language_override : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Environment

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.update(
            environment_id="us_env_YOUR_ID",
            name="dev",
            is_prod=False,
            guest_authentication=["magic_link"],
            metadata={"key": "value"},
            namespaces=["default"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}",
            method="PATCH",
            json={
                "name": name,
                "isProd": is_prod,
                "guestAuthentication": guest_authentication,
                "metadata": metadata,
                "translationsPath": translations_path,
                "namespaces": namespaces,
                "languageOverride": language_override,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Environment,
                    parse_obj_as(
                        type_=Environment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Deletes a single environment

        Parameters
        ----------
        environment_id : str
            ID of the environment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.delete(
            environment_id="environmentId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_guides(
        self, environment_id: EnvironmentId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GuideListResponse:
        """
        Returns guides in an account

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of the environment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideListResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.list_guides(
            environment_id="environmentId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}/guides",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideListResponse,
                    parse_obj_as(
                        type_=GuideListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_guide(
        self,
        environment_id: EnvironmentId,
        guide_id: GuideId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideDetailResponse:
        """
        Returns a guide

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of the environment

        guide_id : GuideId
            ID of guide

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideDetailResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.get_guide(
            environment_id="us_env_YOUR_ID",
            guide_id="us_gu_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}/guides/{jsonable_encoder(guide_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideDetailResponse,
                    parse_obj_as(
                        type_=GuideDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_guide(
        self,
        environment_id_: EnvironmentId,
        guide_id: GuideId,
        *,
        description: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        slug: typing.Optional[str] = OMIT,
        versions: typing.Optional[typing.Sequence[GuideVersionResource]] = OMIT,
        blocks: typing.Optional[typing.Sequence[typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]]] = OMIT,
        environment_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideDetailResponse:
        """
        Updates a guide

        Parameters
        ----------
        environment_id_ : EnvironmentId
            ID of the environment

        guide_id : GuideId
            ID of guide

        description : typing.Optional[str]

        title : typing.Optional[str]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        slug : typing.Optional[str]

        versions : typing.Optional[typing.Sequence[GuideVersionResource]]

        blocks : typing.Optional[typing.Sequence[typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]]]

        environment_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideDetailResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.update_guide(
            environment_id_="us_env_YOUR_ID",
            guide_id="us_gu_YOUR_ID",
            description="Updated getting started guide",
            title="Data import made easy",
            slug="getting-started",
            environment_id="commons.EnvironmentId",
            metadata={"category": "onboarding"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id_)}/guides/{jsonable_encoder(guide_id)}",
            method="PATCH",
            json={
                "description": description,
                "title": title,
                "metadata": metadata,
                "slug": slug,
                "versions": convert_and_respect_annotation_metadata(
                    object_=versions, annotation=typing.Sequence[GuideVersionResource], direction="write"
                ),
                "blocks": blocks,
                "environmentId": environment_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideDetailResponse,
                    parse_obj_as(
                        type_=GuideDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_guide(
        self,
        environment_id_: EnvironmentId,
        *,
        description: str,
        title: str,
        slug: str,
        versions: typing.Sequence[GuideVersionResource],
        blocks: typing.Sequence[typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]],
        environment_id: str,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideDetailResponse:
        """
        Creates a guide

        Parameters
        ----------
        environment_id_ : EnvironmentId
            ID of the environment

        description : str

        title : str

        slug : str

        versions : typing.Sequence[GuideVersionResource]

        blocks : typing.Sequence[typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]]

        environment_id : str

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideDetailResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.create_guide(
            environment_id_="us_env_YOUR_ID",
            description="Getting started guide",
            title="Data import made easy",
            slug="getting-started",
            environment_id="commons.EnvironmentId",
            versions=[],
            blocks=[],
            metadata={"category": "onboarding"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id_)}/guides",
            method="POST",
            json={
                "description": description,
                "title": title,
                "metadata": metadata,
                "slug": slug,
                "versions": convert_and_respect_annotation_metadata(
                    object_=versions, annotation=typing.Sequence[GuideVersionResource], direction="write"
                ),
                "blocks": blocks,
                "environmentId": environment_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideDetailResponse,
                    parse_obj_as(
                        type_=GuideDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_guide(
        self,
        environment_id: EnvironmentId,
        guide_id: GuideId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideDeleteResponse:
        """
        Deletes a guide

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of the environment

        guide_id : GuideId
            ID of guide to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideDeleteResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.delete_guide(
            environment_id="us_env_YOUR_ID",
            guide_id="us_gu_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}/guides/{jsonable_encoder(guide_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideDeleteResponse,
                    parse_obj_as(
                        type_=GuideDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_guide_version(
        self,
        environment_id: EnvironmentId,
        guide_id: GuideId,
        version: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideVersionResponse:
        """
        Returns a specified version of a specific guide

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of the environment

        guide_id : GuideId
            ID of the guide

        version : int
            Version of the guide

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideVersionResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.environments.get_guide_version(
            environment_id="environmentId",
            guide_id="guideId",
            version=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}/guides/{jsonable_encoder(guide_id)}/versions/{jsonable_encoder(version)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideVersionResponse,
                    parse_obj_as(
                        type_=GuideVersionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncEnvironmentsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListEnvironmentsResponse:
        """
        Get all environments

        Parameters
        ----------
        page_size : typing.Optional[int]
            Number of environments to return in a page (default 10)

        page_number : typing.Optional[int]
            Based on pageSize, which page of environments to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListEnvironmentsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "environments",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListEnvironmentsResponse,
                    parse_obj_as(
                        type_=ListEnvironmentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        name: str,
        is_prod: bool,
        guest_authentication: typing.Optional[typing.Sequence[GuestAuthenticationEnum]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        translations_path: typing.Optional[str] = OMIT,
        namespaces: typing.Optional[typing.Sequence[str]] = OMIT,
        language_override: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EnvironmentResponse:
        """
        Create a new environment

        Parameters
        ----------
        name : str
            The name of the environment

        is_prod : bool
            Whether or not the environment is a production environment

        guest_authentication : typing.Optional[typing.Sequence[GuestAuthenticationEnum]]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        translations_path : typing.Optional[str]

        namespaces : typing.Optional[typing.Sequence[str]]

        language_override : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EnvironmentResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.create(
                name="dev",
                is_prod=False,
                guest_authentication=["magic_link"],
                metadata={"key": "value"},
                namespaces=["default"],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "environments",
            method="POST",
            json={
                "name": name,
                "isProd": is_prod,
                "guestAuthentication": guest_authentication,
                "metadata": metadata,
                "translationsPath": translations_path,
                "namespaces": namespaces,
                "languageOverride": language_override,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EnvironmentResponse,
                    parse_obj_as(
                        type_=EnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_environment_event_token(
        self, *, environment_id: EnvironmentId, request_options: typing.Optional[RequestOptions] = None
    ) -> EventTokenResponse:
        """
        Get a token which can be used to subscribe to events for this environment

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of environment to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EventTokenResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.get_environment_event_token(
                environment_id="us_env_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "environments/subscription-token",
            method="GET",
            params={
                "environmentId": environment_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EventTokenResponse,
                    parse_obj_as(
                        type_=EventTokenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EnvironmentResponse:
        """
        Returns a single environment

        Parameters
        ----------
        environment_id : str
            ID of the environment to return. To fetch the current environment, pass `current`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EnvironmentResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.get(
                environment_id="us_env_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EnvironmentResponse,
                    parse_obj_as(
                        type_=EnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        environment_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        is_prod: typing.Optional[bool] = OMIT,
        guest_authentication: typing.Optional[typing.Sequence[GuestAuthenticationEnum]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        translations_path: typing.Optional[str] = OMIT,
        namespaces: typing.Optional[typing.Sequence[str]] = OMIT,
        language_override: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Environment:
        """
        Updates a single environment, to change the name for example

        Parameters
        ----------
        environment_id : str
            ID of the environment to update

        name : typing.Optional[str]
            The name of the environment

        is_prod : typing.Optional[bool]
            Whether or not the environment is a production environment

        guest_authentication : typing.Optional[typing.Sequence[GuestAuthenticationEnum]]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        translations_path : typing.Optional[str]

        namespaces : typing.Optional[typing.Sequence[str]]

        language_override : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Environment

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.update(
                environment_id="us_env_YOUR_ID",
                name="dev",
                is_prod=False,
                guest_authentication=["magic_link"],
                metadata={"key": "value"},
                namespaces=["default"],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}",
            method="PATCH",
            json={
                "name": name,
                "isProd": is_prod,
                "guestAuthentication": guest_authentication,
                "metadata": metadata,
                "translationsPath": translations_path,
                "namespaces": namespaces,
                "languageOverride": language_override,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Environment,
                    parse_obj_as(
                        type_=Environment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Success:
        """
        Deletes a single environment

        Parameters
        ----------
        environment_id : str
            ID of the environment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.delete(
                environment_id="environmentId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_guides(
        self, environment_id: EnvironmentId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GuideListResponse:
        """
        Returns guides in an account

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of the environment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideListResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.list_guides(
                environment_id="environmentId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}/guides",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideListResponse,
                    parse_obj_as(
                        type_=GuideListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_guide(
        self,
        environment_id: EnvironmentId,
        guide_id: GuideId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideDetailResponse:
        """
        Returns a guide

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of the environment

        guide_id : GuideId
            ID of guide

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideDetailResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.get_guide(
                environment_id="us_env_YOUR_ID",
                guide_id="us_gu_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}/guides/{jsonable_encoder(guide_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideDetailResponse,
                    parse_obj_as(
                        type_=GuideDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_guide(
        self,
        environment_id_: EnvironmentId,
        guide_id: GuideId,
        *,
        description: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        slug: typing.Optional[str] = OMIT,
        versions: typing.Optional[typing.Sequence[GuideVersionResource]] = OMIT,
        blocks: typing.Optional[typing.Sequence[typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]]] = OMIT,
        environment_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideDetailResponse:
        """
        Updates a guide

        Parameters
        ----------
        environment_id_ : EnvironmentId
            ID of the environment

        guide_id : GuideId
            ID of guide

        description : typing.Optional[str]

        title : typing.Optional[str]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        slug : typing.Optional[str]

        versions : typing.Optional[typing.Sequence[GuideVersionResource]]

        blocks : typing.Optional[typing.Sequence[typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]]]

        environment_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideDetailResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.update_guide(
                environment_id_="us_env_YOUR_ID",
                guide_id="us_gu_YOUR_ID",
                description="Updated getting started guide",
                title="Data import made easy",
                slug="getting-started",
                environment_id="commons.EnvironmentId",
                metadata={"category": "onboarding"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id_)}/guides/{jsonable_encoder(guide_id)}",
            method="PATCH",
            json={
                "description": description,
                "title": title,
                "metadata": metadata,
                "slug": slug,
                "versions": convert_and_respect_annotation_metadata(
                    object_=versions, annotation=typing.Sequence[GuideVersionResource], direction="write"
                ),
                "blocks": blocks,
                "environmentId": environment_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideDetailResponse,
                    parse_obj_as(
                        type_=GuideDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_guide(
        self,
        environment_id_: EnvironmentId,
        *,
        description: str,
        title: str,
        slug: str,
        versions: typing.Sequence[GuideVersionResource],
        blocks: typing.Sequence[typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]],
        environment_id: str,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideDetailResponse:
        """
        Creates a guide

        Parameters
        ----------
        environment_id_ : EnvironmentId
            ID of the environment

        description : str

        title : str

        slug : str

        versions : typing.Sequence[GuideVersionResource]

        blocks : typing.Sequence[typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]]

        environment_id : str

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideDetailResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.create_guide(
                environment_id_="us_env_YOUR_ID",
                description="Getting started guide",
                title="Data import made easy",
                slug="getting-started",
                environment_id="commons.EnvironmentId",
                versions=[],
                blocks=[],
                metadata={"category": "onboarding"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id_)}/guides",
            method="POST",
            json={
                "description": description,
                "title": title,
                "metadata": metadata,
                "slug": slug,
                "versions": convert_and_respect_annotation_metadata(
                    object_=versions, annotation=typing.Sequence[GuideVersionResource], direction="write"
                ),
                "blocks": blocks,
                "environmentId": environment_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideDetailResponse,
                    parse_obj_as(
                        type_=GuideDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_guide(
        self,
        environment_id: EnvironmentId,
        guide_id: GuideId,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideDeleteResponse:
        """
        Deletes a guide

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of the environment

        guide_id : GuideId
            ID of guide to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideDeleteResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.delete_guide(
                environment_id="us_env_YOUR_ID",
                guide_id="us_gu_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}/guides/{jsonable_encoder(guide_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideDeleteResponse,
                    parse_obj_as(
                        type_=GuideDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_guide_version(
        self,
        environment_id: EnvironmentId,
        guide_id: GuideId,
        version: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GuideVersionResponse:
        """
        Returns a specified version of a specific guide

        Parameters
        ----------
        environment_id : EnvironmentId
            ID of the environment

        guide_id : GuideId
            ID of the guide

        version : int
            Version of the guide

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GuideVersionResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.environments.get_guide_version(
                environment_id="environmentId",
                guide_id="guideId",
                version=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"environments/{jsonable_encoder(environment_id)}/guides/{jsonable_encoder(guide_id)}/versions/{jsonable_encoder(version)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GuideVersionResponse,
                    parse_obj_as(
                        type_=GuideVersionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
