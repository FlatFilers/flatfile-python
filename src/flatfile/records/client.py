# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..commons.types.sheet_id import SheetId
from ..commons.types.version_id import VersionId
from ..commons.types.commit_id import CommitId
from ..commons.types.sort_field import SortField
from ..commons.types.sort_direction import SortDirection
from ..commons.types.filter import Filter
from ..commons.types.filter_field import FilterField
from ..commons.types.search_value import SearchValue
from ..commons.types.search_field import SearchField
from ..commons.types.record_id import RecordId
from ..commons.types.event_id import EventId
from ..core.request_options import RequestOptions
from .types.get_records_response import GetRecordsResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..commons.errors.bad_request_error import BadRequestError
from ..commons.types.errors import Errors
from ..commons.errors.not_found_error import NotFoundError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.get_record_indices_response import GetRecordIndicesResponse
from .types.records import Records
from ..versions.types.version_response import VersionResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from .types.record_data import RecordData
from .types.records_response import RecordsResponse
from ..commons.types.success import Success
from .types.cell_value_union import CellValueUnion
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RecordsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[VersionId] = None,
        commit_id: typing.Optional[CommitId] = None,
        since_version_id: typing.Optional[VersionId] = None,
        since_commit_id: typing.Optional[CommitId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        include_counts: typing.Optional[bool] = None,
        include_length: typing.Optional[bool] = None,
        include_links: typing.Optional[bool] = None,
        include_messages: typing.Optional[bool] = None,
        fields: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        for_: typing.Optional[EventId] = None,
        q: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetRecordsResponse:
        """
        Returns records from a sheet in a workbook

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        version_id : typing.Optional[VersionId]
            Deprecated, use `commitId` instead.

        commit_id : typing.Optional[CommitId]

        since_version_id : typing.Optional[VersionId]
            Deprecated, use `sinceCommitId` instead.

        since_commit_id : typing.Optional[CommitId]

        sort_field : typing.Optional[SortField]

        sort_direction : typing.Optional[SortDirection]

        filter : typing.Optional[Filter]

        filter_field : typing.Optional[FilterField]
            Name of field by which to filter records

        search_value : typing.Optional[SearchValue]

        search_field : typing.Optional[SearchField]

        ids : typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]]
            The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records. Maximum of 100 allowed.

        page_size : typing.Optional[int]
            Number of records to return in a page (default 10,000)

        page_number : typing.Optional[int]
            Based on pageSize, which page of records to return (Note - numbers start at 1)

        include_counts : typing.Optional[bool]
            **DEPRECATED** Use GET /sheets/:sheetId/counts

        include_length : typing.Optional[bool]
            The length of the record result set, returned as counts.total

        include_links : typing.Optional[bool]
            If true, linked records will be included in the results. Defaults to false.

        include_messages : typing.Optional[bool]
            Include error messages, defaults to false.

        fields : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of field keys to include in the response. If not provided, all fields will be included.

        for_ : typing.Optional[EventId]
            if "for" is provided, the query parameters will be pulled from the event payload

        q : typing.Optional[str]
            An FFQL query used to filter the result set

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetRecordsResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.records.get(
            sheet_id="us_sh_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records",
            method="GET",
            params={
                "versionId": version_id,
                "commitId": commit_id,
                "sinceVersionId": since_version_id,
                "sinceCommitId": since_commit_id,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "ids": ids,
                "pageSize": page_size,
                "pageNumber": page_number,
                "includeCounts": include_counts,
                "includeLength": include_length,
                "includeLinks": include_links,
                "includeMessages": include_messages,
                "fields": fields,
                "for": for_,
                "q": q,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetRecordsResponse,
                    parse_obj_as(
                        type_=GetRecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def indices(
        self,
        sheet_id: SheetId,
        *,
        ids: typing.Union[RecordId, typing.Sequence[RecordId]],
        commit_id: typing.Optional[CommitId] = None,
        since_commit_id: typing.Optional[CommitId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        q: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetRecordIndicesResponse:
        """
        Returns indices of records from a sheet in a workbook

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        ids : typing.Union[RecordId, typing.Sequence[RecordId]]
            List of record IDs to include in the query. Limit 100.

        commit_id : typing.Optional[CommitId]

        since_commit_id : typing.Optional[CommitId]

        sort_field : typing.Optional[SortField]

        sort_direction : typing.Optional[SortDirection]

        filter : typing.Optional[Filter]

        filter_field : typing.Optional[FilterField]
            Name of field by which to filter records

        search_value : typing.Optional[SearchValue]

        search_field : typing.Optional[SearchField]

        q : typing.Optional[str]
            An FFQL query used to filter the result set

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetRecordIndicesResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.records.indices(
            sheet_id="us_sh_YOUR_ID",
            ids="list<$commons.RecordId.Example0, $commons.RecordId.Example1>",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records/indices",
            method="GET",
            params={
                "commitId": commit_id,
                "sinceCommitId": since_commit_id,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "ids": ids,
                "q": q,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetRecordIndicesResponse,
                    parse_obj_as(
                        type_=GetRecordIndicesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self, sheet_id: SheetId, *, request: Records, request_options: typing.Optional[RequestOptions] = None
    ) -> VersionResponse:
        """
        Updates existing records in a workbook sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request : Records

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VersionResponse

        Examples
        --------
        from flatfile import Flatfile
        from flatfile.records import CellValue, Record, RecordConfig

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.records.update(
            sheet_id="us_sh_YOUR_ID",
            request=[
                Record(
                    id="us_rc_YOUR_ID",
                    version_id="us_vr_YOUR_ID",
                    commit_id="us_vr_YOUR_ID",
                    values={
                        "firstName": CellValue(
                            value="John",
                            messages=[],
                            valid=True,
                        ),
                        "lastName": CellValue(
                            value="Smith",
                            messages=[],
                            valid=True,
                        ),
                        "email": CellValue(
                            value="john.smith@example.com",
                            messages=[],
                            valid=True,
                        ),
                    },
                    valid=True,
                    metadata={},
                    config=RecordConfig(),
                )
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records",
            method="PUT",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=Records, direction="write"),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VersionResponse,
                    parse_obj_as(
                        type_=VersionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def insert(
        self,
        sheet_id: SheetId,
        *,
        request: typing.Sequence[RecordData],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RecordsResponse:
        """
        Adds records to a workbook sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request : typing.Sequence[RecordData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RecordsResponse

        Examples
        --------
        from flatfile import Flatfile
        from flatfile.records import CellValue

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.records.insert(
            sheet_id="us_sh_YOUR_ID",
            request=[
                {
                    "firstName": CellValue(
                        value="John",
                        messages=[],
                        valid=True,
                    ),
                    "lastName": CellValue(
                        value="Smith",
                        messages=[],
                        valid=True,
                    ),
                    "email": CellValue(
                        value="john.smith@example.com",
                        messages=[],
                        valid=True,
                    ),
                }
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[RecordData], direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RecordsResponse,
                    parse_obj_as(
                        type_=RecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(
        self,
        sheet_id: SheetId,
        *,
        ids: typing.Union[RecordId, typing.Sequence[RecordId]],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Success:
        """
        Deletes records from a workbook sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        ids : typing.Union[RecordId, typing.Sequence[RecordId]]
            A list of record IDs to delete. Maximum of 100 allowed.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.records.delete(
            sheet_id="us_sh_YOUR_ID",
            ids="us_rc_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records",
            method="DELETE",
            params={
                "ids": ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def find_and_replace(
        self,
        sheet_id: SheetId,
        *,
        field_key: str,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]] = None,
        q: typing.Optional[str] = None,
        find: typing.Optional[CellValueUnion] = OMIT,
        replace: typing.Optional[CellValueUnion] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VersionResponse:
        """
        Searches for all values that match the 'find' value (globally or for a specific field via 'fieldKey') and replaces them with the 'replace' value. Wrap 'find' value in double quotes for exact match (""). Returns a commitId for the updated records

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        field_key : str
            A unique key used to identify a field in a sheet

        filter : typing.Optional[Filter]

        filter_field : typing.Optional[FilterField]
            Name of field by which to filter records

        search_value : typing.Optional[SearchValue]

        search_field : typing.Optional[SearchField]

        ids : typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]]
            The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records

        q : typing.Optional[str]
            An FFQL query used to filter the result set

        find : typing.Optional[CellValueUnion]
            A value to find for a given field in a sheet. For exact matches, wrap the value in double quotes ("Bob")

        replace : typing.Optional[CellValueUnion]
            The value to replace found values with

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VersionResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.records.find_and_replace(
            sheet_id="us_sh_YOUR_ID",
            field_key="email",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/find-replace",
            method="PUT",
            params={
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "ids": ids,
                "q": q,
            },
            json={
                "find": convert_and_respect_annotation_metadata(
                    object_=find, annotation=CellValueUnion, direction="write"
                ),
                "replace": convert_and_respect_annotation_metadata(
                    object_=replace, annotation=CellValueUnion, direction="write"
                ),
                "fieldKey": field_key,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VersionResponse,
                    parse_obj_as(
                        type_=VersionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncRecordsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        sheet_id: SheetId,
        *,
        version_id: typing.Optional[VersionId] = None,
        commit_id: typing.Optional[CommitId] = None,
        since_version_id: typing.Optional[VersionId] = None,
        since_commit_id: typing.Optional[CommitId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]] = None,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        include_counts: typing.Optional[bool] = None,
        include_length: typing.Optional[bool] = None,
        include_links: typing.Optional[bool] = None,
        include_messages: typing.Optional[bool] = None,
        fields: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        for_: typing.Optional[EventId] = None,
        q: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetRecordsResponse:
        """
        Returns records from a sheet in a workbook

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        version_id : typing.Optional[VersionId]
            Deprecated, use `commitId` instead.

        commit_id : typing.Optional[CommitId]

        since_version_id : typing.Optional[VersionId]
            Deprecated, use `sinceCommitId` instead.

        since_commit_id : typing.Optional[CommitId]

        sort_field : typing.Optional[SortField]

        sort_direction : typing.Optional[SortDirection]

        filter : typing.Optional[Filter]

        filter_field : typing.Optional[FilterField]
            Name of field by which to filter records

        search_value : typing.Optional[SearchValue]

        search_field : typing.Optional[SearchField]

        ids : typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]]
            The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records. Maximum of 100 allowed.

        page_size : typing.Optional[int]
            Number of records to return in a page (default 10,000)

        page_number : typing.Optional[int]
            Based on pageSize, which page of records to return (Note - numbers start at 1)

        include_counts : typing.Optional[bool]
            **DEPRECATED** Use GET /sheets/:sheetId/counts

        include_length : typing.Optional[bool]
            The length of the record result set, returned as counts.total

        include_links : typing.Optional[bool]
            If true, linked records will be included in the results. Defaults to false.

        include_messages : typing.Optional[bool]
            Include error messages, defaults to false.

        fields : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A list of field keys to include in the response. If not provided, all fields will be included.

        for_ : typing.Optional[EventId]
            if "for" is provided, the query parameters will be pulled from the event payload

        q : typing.Optional[str]
            An FFQL query used to filter the result set

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetRecordsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.records.get(
                sheet_id="us_sh_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records",
            method="GET",
            params={
                "versionId": version_id,
                "commitId": commit_id,
                "sinceVersionId": since_version_id,
                "sinceCommitId": since_commit_id,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "ids": ids,
                "pageSize": page_size,
                "pageNumber": page_number,
                "includeCounts": include_counts,
                "includeLength": include_length,
                "includeLinks": include_links,
                "includeMessages": include_messages,
                "fields": fields,
                "for": for_,
                "q": q,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetRecordsResponse,
                    parse_obj_as(
                        type_=GetRecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def indices(
        self,
        sheet_id: SheetId,
        *,
        ids: typing.Union[RecordId, typing.Sequence[RecordId]],
        commit_id: typing.Optional[CommitId] = None,
        since_commit_id: typing.Optional[CommitId] = None,
        sort_field: typing.Optional[SortField] = None,
        sort_direction: typing.Optional[SortDirection] = None,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        q: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetRecordIndicesResponse:
        """
        Returns indices of records from a sheet in a workbook

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        ids : typing.Union[RecordId, typing.Sequence[RecordId]]
            List of record IDs to include in the query. Limit 100.

        commit_id : typing.Optional[CommitId]

        since_commit_id : typing.Optional[CommitId]

        sort_field : typing.Optional[SortField]

        sort_direction : typing.Optional[SortDirection]

        filter : typing.Optional[Filter]

        filter_field : typing.Optional[FilterField]
            Name of field by which to filter records

        search_value : typing.Optional[SearchValue]

        search_field : typing.Optional[SearchField]

        q : typing.Optional[str]
            An FFQL query used to filter the result set

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetRecordIndicesResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.records.indices(
                sheet_id="us_sh_YOUR_ID",
                ids="list<$commons.RecordId.Example0, $commons.RecordId.Example1>",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records/indices",
            method="GET",
            params={
                "commitId": commit_id,
                "sinceCommitId": since_commit_id,
                "sortField": sort_field,
                "sortDirection": sort_direction,
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "ids": ids,
                "q": q,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetRecordIndicesResponse,
                    parse_obj_as(
                        type_=GetRecordIndicesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self, sheet_id: SheetId, *, request: Records, request_options: typing.Optional[RequestOptions] = None
    ) -> VersionResponse:
        """
        Updates existing records in a workbook sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request : Records

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VersionResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile
        from flatfile.records import CellValue, Record, RecordConfig

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.records.update(
                sheet_id="us_sh_YOUR_ID",
                request=[
                    Record(
                        id="us_rc_YOUR_ID",
                        version_id="us_vr_YOUR_ID",
                        commit_id="us_vr_YOUR_ID",
                        values={
                            "firstName": CellValue(
                                value="John",
                                messages=[],
                                valid=True,
                            ),
                            "lastName": CellValue(
                                value="Smith",
                                messages=[],
                                valid=True,
                            ),
                            "email": CellValue(
                                value="john.smith@example.com",
                                messages=[],
                                valid=True,
                            ),
                        },
                        valid=True,
                        metadata={},
                        config=RecordConfig(),
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records",
            method="PUT",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=Records, direction="write"),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VersionResponse,
                    parse_obj_as(
                        type_=VersionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def insert(
        self,
        sheet_id: SheetId,
        *,
        request: typing.Sequence[RecordData],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RecordsResponse:
        """
        Adds records to a workbook sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        request : typing.Sequence[RecordData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RecordsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile
        from flatfile.records import CellValue

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.records.insert(
                sheet_id="us_sh_YOUR_ID",
                request=[
                    {
                        "firstName": CellValue(
                            value="John",
                            messages=[],
                            valid=True,
                        ),
                        "lastName": CellValue(
                            value="Smith",
                            messages=[],
                            valid=True,
                        ),
                        "email": CellValue(
                            value="john.smith@example.com",
                            messages=[],
                            valid=True,
                        ),
                    }
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[RecordData], direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RecordsResponse,
                    parse_obj_as(
                        type_=RecordsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self,
        sheet_id: SheetId,
        *,
        ids: typing.Union[RecordId, typing.Sequence[RecordId]],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Success:
        """
        Deletes records from a workbook sheet

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        ids : typing.Union[RecordId, typing.Sequence[RecordId]]
            A list of record IDs to delete. Maximum of 100 allowed.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Success

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.records.delete(
                sheet_id="us_sh_YOUR_ID",
                ids="us_rc_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/records",
            method="DELETE",
            params={
                "ids": ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Success,
                    parse_obj_as(
                        type_=Success,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Errors,
                        parse_obj_as(
                            type_=Errors,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def find_and_replace(
        self,
        sheet_id: SheetId,
        *,
        field_key: str,
        filter: typing.Optional[Filter] = None,
        filter_field: typing.Optional[FilterField] = None,
        search_value: typing.Optional[SearchValue] = None,
        search_field: typing.Optional[SearchField] = None,
        ids: typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]] = None,
        q: typing.Optional[str] = None,
        find: typing.Optional[CellValueUnion] = OMIT,
        replace: typing.Optional[CellValueUnion] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VersionResponse:
        """
        Searches for all values that match the 'find' value (globally or for a specific field via 'fieldKey') and replaces them with the 'replace' value. Wrap 'find' value in double quotes for exact match (""). Returns a commitId for the updated records

        Parameters
        ----------
        sheet_id : SheetId
            ID of sheet

        field_key : str
            A unique key used to identify a field in a sheet

        filter : typing.Optional[Filter]

        filter_field : typing.Optional[FilterField]
            Name of field by which to filter records

        search_value : typing.Optional[SearchValue]

        search_field : typing.Optional[SearchField]

        ids : typing.Optional[typing.Union[RecordId, typing.Sequence[RecordId]]]
            The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records

        q : typing.Optional[str]
            An FFQL query used to filter the result set

        find : typing.Optional[CellValueUnion]
            A value to find for a given field in a sheet. For exact matches, wrap the value in double quotes ("Bob")

        replace : typing.Optional[CellValueUnion]
            The value to replace found values with

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VersionResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.records.find_and_replace(
                sheet_id="us_sh_YOUR_ID",
                field_key="email",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sheets/{jsonable_encoder(sheet_id)}/find-replace",
            method="PUT",
            params={
                "filter": filter,
                "filterField": filter_field,
                "searchValue": search_value,
                "searchField": search_field,
                "ids": ids,
                "q": q,
            },
            json={
                "find": convert_and_respect_annotation_metadata(
                    object_=find, annotation=CellValueUnion, direction="write"
                ),
                "replace": convert_and_respect_annotation_metadata(
                    object_=replace, annotation=CellValueUnion, direction="write"
                ),
                "fieldKey": field_key,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VersionResponse,
                    parse_obj_as(
                        type_=VersionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
