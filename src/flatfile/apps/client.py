# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from .types.apps_response import AppsResponse
from ..core.pydantic_utilities import parse_obj_as
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..commons.types.app_id import AppId
from .types.app_response import AppResponse
from ..core.jsonable_encoder import jsonable_encoder
import datetime as dt
from .types.app_type import AppType
from .types.success_response import SuccessResponse
from .types.constraints_response import ConstraintsResponse
from .types.constraint_response import ConstraintResponse
from ..commons.types.constraint_id import ConstraintId
from .types.constraint_versions_response import ConstraintVersionsResponse
from .types.constraint_version_response import ConstraintVersionResponse
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AppsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> AppsResponse:
        """
        Returns apps in an account

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppsResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "apps",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AppsResponse,
                    parse_obj_as(
                        type_=AppsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, app_id: AppId, *, request_options: typing.Optional[RequestOptions] = None) -> AppResponse:
        """
        Returns an app

        Parameters
        ----------
        app_id : AppId
            ID of app

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.get(
            app_id="us_app_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AppResponse,
                    parse_obj_as(
                        type_=AppResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        app_id: AppId,
        *,
        name: typing.Optional[str] = OMIT,
        namespace: typing.Optional[str] = OMIT,
        entity: typing.Optional[str] = OMIT,
        entity_plural: typing.Optional[str] = OMIT,
        icon: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        environment_filters: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        blueprint: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        activated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AppResponse:
        """
        Updates an app

        Parameters
        ----------
        app_id : AppId
            ID of app

        name : typing.Optional[str]

        namespace : typing.Optional[str]

        entity : typing.Optional[str]

        entity_plural : typing.Optional[str]

        icon : typing.Optional[str]

        metadata : typing.Optional[typing.Optional[typing.Any]]

        environment_filters : typing.Optional[typing.Optional[typing.Any]]

        blueprint : typing.Optional[typing.Optional[typing.Any]]

        activated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.update(
            app_id="us_app_YOUR_ID",
            name="Nightly Data Loads",
            namespace="nightly-data",
            entity="Sync",
            entity_plural="Syncs",
            icon='<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-bar-chart-fill" viewBox="0 0 16 16">\n  <path d="M1 11a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1zm5-4a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1zm5-5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1z"/>\n</svg>',
            metadata={"foo": "bar"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}",
            method="PATCH",
            json={
                "name": name,
                "namespace": namespace,
                "entity": entity,
                "entityPlural": entity_plural,
                "icon": icon,
                "metadata": metadata,
                "environmentFilters": environment_filters,
                "blueprint": blueprint,
                "activatedAt": activated_at,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AppResponse,
                    parse_obj_as(
                        type_=AppResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        name: str,
        namespace: str,
        type: AppType,
        entity: typing.Optional[str] = OMIT,
        entity_plural: typing.Optional[str] = OMIT,
        icon: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        environment_filters: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        blueprint: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AppResponse:
        """
        Creates an app

        Parameters
        ----------
        name : str

        namespace : str

        type : AppType

        entity : typing.Optional[str]

        entity_plural : typing.Optional[str]

        icon : typing.Optional[str]

        metadata : typing.Optional[typing.Optional[typing.Any]]

        environment_filters : typing.Optional[typing.Optional[typing.Any]]

        blueprint : typing.Optional[typing.Optional[typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.create(
            name="Nightly Data Loads",
            namespace="nightly-data",
            type="CUSTOM",
            entity="Sync",
            entity_plural="Syncs",
            icon='<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-bar-chart-fill" viewBox="0 0 16 16">\n  <path d="M1 11a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1zm5-4a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1zm5-5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1z"/>\n</svg>',
            metadata={"foo": "bar"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "apps",
            method="POST",
            json={
                "name": name,
                "namespace": namespace,
                "type": type,
                "entity": entity,
                "entityPlural": entity_plural,
                "icon": icon,
                "metadata": metadata,
                "environmentFilters": environment_filters,
                "blueprint": blueprint,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AppResponse,
                    parse_obj_as(
                        type_=AppResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, app_id: AppId, *, request_options: typing.Optional[RequestOptions] = None) -> SuccessResponse:
        """
        Deletes an app

        Parameters
        ----------
        app_id : AppId
            ID of app to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SuccessResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.delete(
            app_id="us_app_YOUR_ID",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SuccessResponse,
                    parse_obj_as(
                        type_=SuccessResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_constraints(
        self,
        app_id: AppId,
        *,
        include_builtins: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstraintsResponse:
        """
        Returns constraints for an app

        Parameters
        ----------
        app_id : AppId
            ID of the app

        include_builtins : typing.Optional[bool]
            Whether to include built-in constraints

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintsResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.get_constraints(
            app_id="appId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints",
            method="GET",
            params={
                "includeBuiltins": include_builtins,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintsResponse,
                    parse_obj_as(
                        type_=ConstraintsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_constraint(
        self,
        app_id_: AppId,
        *,
        description: typing.Optional[str] = OMIT,
        function: typing.Optional[str] = OMIT,
        options: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        label: typing.Optional[str] = OMIT,
        validator: typing.Optional[str] = OMIT,
        app_id: typing.Optional[AppId] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstraintResponse:
        """
        Creates a new constraint for an app

        Parameters
        ----------
        app_id_ : AppId
            ID of the app

        description : typing.Optional[str]

        function : typing.Optional[str]

        options : typing.Optional[typing.Optional[typing.Any]]

        label : typing.Optional[str]

        validator : typing.Optional[str]

        app_id : typing.Optional[AppId]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.create_constraint(
            app_id_="appId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id_)}/constraints",
            method="POST",
            json={
                "description": description,
                "function": function,
                "options": options,
                "label": label,
                "validator": validator,
                "appId": app_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintResponse,
                    parse_obj_as(
                        type_=ConstraintResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_constraint_by_id(
        self, app_id: AppId, constraint_id: ConstraintId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ConstraintResponse:
        """
        Returns a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.get_constraint_by_id(
            app_id="appId",
            constraint_id="constraintId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintResponse,
                    parse_obj_as(
                        type_=ConstraintResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_constraint_versions(
        self, app_id: AppId, constraint_id: ConstraintId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ConstraintVersionsResponse:
        """
        Returns the versions of a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintVersionsResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.get_constraint_versions(
            app_id="appId",
            constraint_id="constraintId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}/versions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintVersionsResponse,
                    parse_obj_as(
                        type_=ConstraintVersionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_constraint_version(
        self,
        app_id: AppId,
        constraint_id: ConstraintId,
        version: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstraintVersionResponse:
        """
        Returns a specified version of a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        version : int
            Version of the constraint

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintVersionResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.get_constraint_version(
            app_id="appId",
            constraint_id="constraintId",
            version=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}/versions/{jsonable_encoder(version)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintVersionResponse,
                    parse_obj_as(
                        type_=ConstraintVersionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_constraint(
        self,
        app_id: AppId,
        constraint_id: ConstraintId,
        *,
        description: typing.Optional[str] = OMIT,
        function: typing.Optional[str] = OMIT,
        options: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        label: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstraintResponse:
        """
        Updates a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        description : typing.Optional[str]

        function : typing.Optional[str]

        options : typing.Optional[typing.Optional[typing.Any]]

        label : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.update_constraint(
            app_id="appId",
            constraint_id="constraintId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}",
            method="PATCH",
            json={
                "description": description,
                "function": function,
                "options": options,
                "label": label,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintResponse,
                    parse_obj_as(
                        type_=ConstraintResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_constraint(
        self, app_id: AppId, constraint_id: ConstraintId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SuccessResponse:
        """
        Deletes a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SuccessResponse

        Examples
        --------
        from flatfile import Flatfile

        client = Flatfile(
            token="YOUR_TOKEN",
        )
        client.apps.delete_constraint(
            app_id="appId",
            constraint_id="constraintId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SuccessResponse,
                    parse_obj_as(
                        type_=SuccessResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAppsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> AppsResponse:
        """
        Returns apps in an account

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "apps",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AppsResponse,
                    parse_obj_as(
                        type_=AppsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, app_id: AppId, *, request_options: typing.Optional[RequestOptions] = None) -> AppResponse:
        """
        Returns an app

        Parameters
        ----------
        app_id : AppId
            ID of app

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.get(
                app_id="us_app_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AppResponse,
                    parse_obj_as(
                        type_=AppResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        app_id: AppId,
        *,
        name: typing.Optional[str] = OMIT,
        namespace: typing.Optional[str] = OMIT,
        entity: typing.Optional[str] = OMIT,
        entity_plural: typing.Optional[str] = OMIT,
        icon: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        environment_filters: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        blueprint: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        activated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AppResponse:
        """
        Updates an app

        Parameters
        ----------
        app_id : AppId
            ID of app

        name : typing.Optional[str]

        namespace : typing.Optional[str]

        entity : typing.Optional[str]

        entity_plural : typing.Optional[str]

        icon : typing.Optional[str]

        metadata : typing.Optional[typing.Optional[typing.Any]]

        environment_filters : typing.Optional[typing.Optional[typing.Any]]

        blueprint : typing.Optional[typing.Optional[typing.Any]]

        activated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.update(
                app_id="us_app_YOUR_ID",
                name="Nightly Data Loads",
                namespace="nightly-data",
                entity="Sync",
                entity_plural="Syncs",
                icon='<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-bar-chart-fill" viewBox="0 0 16 16">\n  <path d="M1 11a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1zm5-4a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1zm5-5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1z"/>\n</svg>',
                metadata={"foo": "bar"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}",
            method="PATCH",
            json={
                "name": name,
                "namespace": namespace,
                "entity": entity,
                "entityPlural": entity_plural,
                "icon": icon,
                "metadata": metadata,
                "environmentFilters": environment_filters,
                "blueprint": blueprint,
                "activatedAt": activated_at,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AppResponse,
                    parse_obj_as(
                        type_=AppResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        name: str,
        namespace: str,
        type: AppType,
        entity: typing.Optional[str] = OMIT,
        entity_plural: typing.Optional[str] = OMIT,
        icon: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        environment_filters: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        blueprint: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AppResponse:
        """
        Creates an app

        Parameters
        ----------
        name : str

        namespace : str

        type : AppType

        entity : typing.Optional[str]

        entity_plural : typing.Optional[str]

        icon : typing.Optional[str]

        metadata : typing.Optional[typing.Optional[typing.Any]]

        environment_filters : typing.Optional[typing.Optional[typing.Any]]

        blueprint : typing.Optional[typing.Optional[typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.create(
                name="Nightly Data Loads",
                namespace="nightly-data",
                type="CUSTOM",
                entity="Sync",
                entity_plural="Syncs",
                icon='<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-bar-chart-fill" viewBox="0 0 16 16">\n  <path d="M1 11a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1zm5-4a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1zm5-5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1z"/>\n</svg>',
                metadata={"foo": "bar"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "apps",
            method="POST",
            json={
                "name": name,
                "namespace": namespace,
                "type": type,
                "entity": entity,
                "entityPlural": entity_plural,
                "icon": icon,
                "metadata": metadata,
                "environmentFilters": environment_filters,
                "blueprint": blueprint,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AppResponse,
                    parse_obj_as(
                        type_=AppResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self, app_id: AppId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SuccessResponse:
        """
        Deletes an app

        Parameters
        ----------
        app_id : AppId
            ID of app to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SuccessResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.delete(
                app_id="us_app_YOUR_ID",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SuccessResponse,
                    parse_obj_as(
                        type_=SuccessResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_constraints(
        self,
        app_id: AppId,
        *,
        include_builtins: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstraintsResponse:
        """
        Returns constraints for an app

        Parameters
        ----------
        app_id : AppId
            ID of the app

        include_builtins : typing.Optional[bool]
            Whether to include built-in constraints

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.get_constraints(
                app_id="appId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints",
            method="GET",
            params={
                "includeBuiltins": include_builtins,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintsResponse,
                    parse_obj_as(
                        type_=ConstraintsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_constraint(
        self,
        app_id_: AppId,
        *,
        description: typing.Optional[str] = OMIT,
        function: typing.Optional[str] = OMIT,
        options: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        label: typing.Optional[str] = OMIT,
        validator: typing.Optional[str] = OMIT,
        app_id: typing.Optional[AppId] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstraintResponse:
        """
        Creates a new constraint for an app

        Parameters
        ----------
        app_id_ : AppId
            ID of the app

        description : typing.Optional[str]

        function : typing.Optional[str]

        options : typing.Optional[typing.Optional[typing.Any]]

        label : typing.Optional[str]

        validator : typing.Optional[str]

        app_id : typing.Optional[AppId]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.create_constraint(
                app_id_="appId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id_)}/constraints",
            method="POST",
            json={
                "description": description,
                "function": function,
                "options": options,
                "label": label,
                "validator": validator,
                "appId": app_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintResponse,
                    parse_obj_as(
                        type_=ConstraintResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_constraint_by_id(
        self, app_id: AppId, constraint_id: ConstraintId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ConstraintResponse:
        """
        Returns a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.get_constraint_by_id(
                app_id="appId",
                constraint_id="constraintId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintResponse,
                    parse_obj_as(
                        type_=ConstraintResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_constraint_versions(
        self, app_id: AppId, constraint_id: ConstraintId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ConstraintVersionsResponse:
        """
        Returns the versions of a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintVersionsResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.get_constraint_versions(
                app_id="appId",
                constraint_id="constraintId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}/versions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintVersionsResponse,
                    parse_obj_as(
                        type_=ConstraintVersionsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_constraint_version(
        self,
        app_id: AppId,
        constraint_id: ConstraintId,
        version: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstraintVersionResponse:
        """
        Returns a specified version of a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        version : int
            Version of the constraint

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintVersionResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.get_constraint_version(
                app_id="appId",
                constraint_id="constraintId",
                version=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}/versions/{jsonable_encoder(version)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintVersionResponse,
                    parse_obj_as(
                        type_=ConstraintVersionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_constraint(
        self,
        app_id: AppId,
        constraint_id: ConstraintId,
        *,
        description: typing.Optional[str] = OMIT,
        function: typing.Optional[str] = OMIT,
        options: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        label: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstraintResponse:
        """
        Updates a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        description : typing.Optional[str]

        function : typing.Optional[str]

        options : typing.Optional[typing.Optional[typing.Any]]

        label : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstraintResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.update_constraint(
                app_id="appId",
                constraint_id="constraintId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}",
            method="PATCH",
            json={
                "description": description,
                "function": function,
                "options": options,
                "label": label,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ConstraintResponse,
                    parse_obj_as(
                        type_=ConstraintResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_constraint(
        self, app_id: AppId, constraint_id: ConstraintId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SuccessResponse:
        """
        Deletes a specific constraint

        Parameters
        ----------
        app_id : AppId
            ID of the app

        constraint_id : ConstraintId
            ID of the constraint

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SuccessResponse

        Examples
        --------
        import asyncio

        from flatfile import AsyncFlatfile

        client = AsyncFlatfile(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.apps.delete_constraint(
                app_id="appId",
                constraint_id="constraintId",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/{jsonable_encoder(app_id)}/constraints/{jsonable_encoder(constraint_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SuccessResponse,
                    parse_obj_as(
                        type_=SuccessResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
